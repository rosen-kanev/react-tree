{"version":3,"file":"react-crann.umd.min.js","sources":["../src/utils.js","../src/regular/TreeItem.jsx","../src/useInternalState.js","../src/regular/Tree.jsx","../src/virtual/VirtualTreeItem.jsx","../src/virtual/VirtualTree.jsx"],"sourcesContent":["export const noop = () => {};\n\nexport const isFn = (value) => typeof value === 'function';\nexport const isUndefined = (value) => typeof value === 'undefined';\n\nexport const getNodeAt = (nodes, index) => {\n    const path = index.split('-');\n    let node = { nodes };\n    let i = 0;\n\n    while (node != null && i < path.length) {\n        node = node.nodes[path[i++]];\n    }\n\n    return i && i === path.length ? node : undefined;\n};\n\nexport const getParentNode = (nodes, index) => {\n    const path = index.split('-');\n\n    return path.length > 1 ? getNodeAt(nodes, path.slice(0, -1).join('-')) : null;\n};\n\nexport const getExpandState = (el) => {\n    const ariaExpandedAttribute = el.getAttribute('aria-expanded');\n\n    return {\n        isExpandable: ariaExpandedAttribute !== null,\n        isExpanded: ariaExpandedAttribute === 'true',\n    };\n};\n\nexport const isLastTopLevelItem = (nodes, index) => {\n    const path = index.split('-');\n\n    return path.length === 1 && parseInt(path[0], 10) === nodes.length - 1;\n};\n\nexport const shallowEquals = (prev, next, ignored) => {\n    if (Object.is(prev, next)) {\n        return true;\n    }\n\n    const keysPrev = Object.keys(prev).filter((key) => !ignored.includes(key));\n    const keysNext = Object.keys(next).filter((key) => !ignored.includes(key));\n\n    if (keysPrev.length !== keysNext.length) {\n        return false;\n    }\n\n    for (const key of keysPrev) {\n        if (!Object.prototype.hasOwnProperty.call(next, key) || !Object.is(prev[key], next[key])) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nexport const internalId = Symbol('id');\n\nexport const addInternalIds = (nodes, parentId) => {\n    let result = [];\n    let i = nodes.length - 1;\n\n    while (i >= 0) {\n        result.push({\n            ...nodes[i],\n            [internalId]: parentId ? `${parentId}-${i}` : `${i}`,\n        });\n\n        i--;\n    }\n\n    return result;\n};\n\nexport const flattenData = (nodes, expanded) => {\n    const stack = addInternalIds(nodes, '');\n    const tree = [];\n\n    while (stack.length) {\n        const node = stack.pop();\n\n        tree.push(node);\n\n        if (expanded.includes(node.id)) {\n            stack.push(...addInternalIds(node.nodes, node[internalId]));\n        }\n    }\n\n    return tree;\n};\n","import { useRef, useEffect, memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst TreeItem = ({\n    node,\n    index,\n    selected,\n    focused,\n    expanded,\n    setSize,\n    counter,\n    onItemSelect,\n    renderLabel,\n    onKeyDown,\n}) => {\n    const isExpandable = node.nodes.length > 0;\n    const isExpanded = isExpandable ? expanded.includes(node.id) : null;\n\n    const path = index.split('-');\n    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n\n    const el = useRef();\n\n    useEffect(() => {\n        if (counter > 0 && focused === node.id) {\n            if (el.current) {\n                el.current.focus();\n                el.current.firstElementChild.scrollIntoView({ block: 'nearest' });\n            }\n        }\n    }, [counter]);\n\n    return (\n        <li\n            ref={el}\n            role=\"treeitem\"\n            tabIndex={focused === node.id ? 0 : -1}\n            aria-expanded={isExpanded}\n            aria-selected={selected === node.id || null}\n            aria-level={path.length}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(node, { isExpandable, isExpanded })\n            ) : (\n                <div onClick={() => onItemSelect(node)}>{node.label}</div>\n            )}\n\n            {isExpanded && isExpandable && (\n                <ul role=\"group\">\n                    {node.nodes.map((n, childIndex) => (\n                        <MemoTreeItem\n                            key={n.id}\n                            node={n}\n                            index={index + '-' + childIndex}\n                            selected={selected}\n                            focused={focused}\n                            expanded={expanded}\n                            setSize={node.nodes.length}\n                            counter={counter}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    ))}\n                </ul>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    TreeItem.displayName = 'TreeItem';\n}\n\nconst propsAreEqual = (prev, next) => {\n    // ignore object identity of these props\n    const ignored = ['counter', 'selected', 'focused', 'expanded', 'onItemSelect', 'onKeyDown'];\n    const areOtherPropsDifferent = !shallowEquals(prev, next, ignored);\n\n    if (areOtherPropsDifferent) {\n        // other props are different - trigger a rerender\n        return false;\n    }\n\n    // breadth first traverse - when working with file system like trees the user usually starts from the outer nodes\n    // and most of the tree changes will be happening near the root of the tree\n    const stack = [{ ...next.node, nodes: [] }, ...next.node.nodes];\n\n    while (stack.length) {\n        const node = stack.shift();\n\n        if (node.id === next.focused || node.id === prev.focused) {\n            // a node or one of its children has to change its `tabIndex` - trigger a rerender\n            return false;\n        }\n\n        if (node.id === next.selected || node.id === prev.selected) {\n            // a node or one of its children has to change its `aria-selected` - trigger a rerender\n            return false;\n        }\n\n        if (prev.expanded.includes(node.id) !== next.expanded.includes(node.id)) {\n            // a node or one of its children has to be collapsed/expanded - trigger a rerender\n            return false;\n        }\n\n        stack.push(...node.nodes);\n    }\n\n    return true;\n};\n\nconst MemoTreeItem = memo(TreeItem, propsAreEqual);\n\nexport default MemoTreeItem;\n","import { useState, useCallback } from 'react';\n\nimport { isUndefined, isFn } from './utils';\n\nconst useInternalState = (valueProp, defaultValue) => {\n    const [valueState, setValueState] = useState(defaultValue);\n    const isUncontrolled = isUndefined(valueProp);\n    const value = isUncontrolled ? valueState : valueProp;\n\n    const updateValue = useCallback(\n        (next) => {\n            if (isUncontrolled) {\n                setValueState(next);\n            }\n        },\n        [isUncontrolled, value]\n    );\n\n    return [value, updateValue];\n};\n\nexport default useInternalState;\n","import { useState, forwardRef, useImperativeHandle, memo } from 'react';\n\nimport TreeItem from './TreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport basePropTypes from '../basePropTypes.js';\n\nimport { isLastTopLevelItem, getExpandState, getParentNode, getNodeAt, noop, isUndefined } from '../utils.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst TreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    const [counter, setCounter] = useState(0);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setCounter((prev) => prev + 1);\n            },\n        };\n    });\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            if (e.currentTarget.dataset.index !== '0') {\n                if (e.currentTarget.previousElementSibling) {\n                    // move back a node and find the deepest leaf node\n                    let item = e.currentTarget.previousElementSibling;\n\n                    while (true) {\n                        const { isExpanded, isExpandable } = getExpandState(item);\n\n                        if (isExpandable && isExpanded) {\n                            // ├─ node_modules\n                            // │  └─ @babel\n                            // │     ├─ code-frame\n                            // │     └─ compat-data (next)\n                            // ├─ src (current)\n                            item = item.lastElementChild.lastElementChild;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    const node = getNodeAt(nodes, item.dataset.index);\n\n                    focusTreeItem(node);\n                } else {\n                    // ├─ node_modules\n                    // │  └─ @babel (next)\n                    // │     ├─ code-frame (current)\n                    // │     └─ compat-data\n                    const parent = getParentNode(nodes, e.currentTarget.dataset.index);\n\n                    if (parent) {\n                        focusTreeItem(parent);\n                    }\n                }\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            const { isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpanded) {\n                // ├─ node_modules (current)\n                // │  └─ @babel (next)\n                // │     ├─ code-frame\n                // │     └─ compat-data\n                // ├─ src\n                const parent = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n                focusTreeItem(parent.nodes[0]);\n            } else {\n                let item = e.currentTarget;\n                // go to parent and find its next sibling until we find a node or reach the end of the tree\n                // ├─ node_modules\n                // │  └─ @babel\n                // │     ├─ code-frame\n                // │     └─ compat-data (current)\n                // ├─ src (next)\n                while (true) {\n                    // ├─ node_modules\n                    // │  └─ @babel\n                    // │     ├─ code-frame\n                    // │     └─ compat-data (current)\n                    if (isLastTopLevelItem(nodes, item.dataset.index)) {\n                        // we are at the end of the tree\n                        break;\n                    }\n\n                    if (item.nextElementSibling) {\n                        item = item.nextElementSibling;\n                        break;\n                    }\n\n                    item = item.parentElement.parentElement;\n                }\n\n                if (item !== e.currentTarget) {\n                    focusTreeItem(getNodeAt(nodes, item.dataset.index));\n                }\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable && isExpanded) {\n                // ├─ src (current)\n                // │ ├─ App.jsx\n                // │ └─ data.js       -> ├─ src (next)\n                // ├─ .editorconfig      ├─ .editorconfig\n                // └─ .gitignore.js      └─ .gitignore.js\n                const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n            } else {\n                // ├─ src (next)\n                // │ ├─ App.jsx\n                // │ └─ data.js (current)\n                // ├─ .editorconfig\n                // └─ .gitignore.js\n                const parent = getParentNode(nodes, e.currentTarget.dataset.index);\n\n                if (parent) {\n                    focusTreeItem(parent);\n                }\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable) {\n                const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n                if (isExpanded) {\n                    // ├─ src (current)\n                    // │ ├─ App.jsx (next)\n                    // │ └─ data.js\n                    // ├─ .editorconfig\n                    // └─ .gitignore.js\n                    const next = node.nodes[0];\n\n                    focusTreeItem(next);\n                } else {\n                    // ├─ src (current)      ├─ src (next)\n                    // ├─ .editorconfig      │ ├─ App.jsx\n                    // └─ .gitignore.js   -> │ └─ data.js\n                    //                       ├─ .editorconfig\n                    //                       └─ .gitignore.js\n                    setExpanded((prev) => prev.concat(node.id));\n                    onExpandChange(node);\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    const focusTreeItem = (node) => {\n        if (node.id !== focused) {\n            setCounter((prev) => prev + 1);\n            setFocused(node.id);\n            onFocusChange(node);\n\n            if (selectionFollowsFocus) {\n                setSelected(node.id);\n                onSelectChange(node);\n            }\n        }\n    };\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    return (\n        <ul role=\"tree\" {...rest}>\n            {nodes.map((node, index) => (\n                <TreeItem\n                    key={node.id}\n                    node={node}\n                    index={`${index}`}\n                    selected={selected}\n                    focused={focused}\n                    expanded={expanded}\n                    setSize={nodes.length}\n                    counter={counter}\n                    renderLabel={renderLabel}\n                    onItemSelect={onItemSelect}\n                    onKeyDown={onKeyDown}\n                />\n            ))}\n        </ul>\n    );\n};\n\nconst Tree = forwardRef(TreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    Tree.displayName = 'Tree';\n    Tree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(Tree);\n","import { memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst VirtualTreeItem = ({\n    node,\n\n    measureRef,\n    start,\n\n    isExpanded,\n    isSelected,\n\n    tabIndex,\n    level,\n    positionInSet,\n    setSize,\n\n    index,\n    counter,\n    isFocused,\n\n    renderLabel,\n    onItemSelect,\n    onKeyDown,\n}) => {\n    return (\n        <li\n            ref={measureRef}\n            role=\"treeitem\"\n            tabIndex={tabIndex}\n            aria-expanded={isExpanded}\n            aria-selected={isSelected || null}\n            aria-level={level}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            style={{\n                position: 'absolute',\n                top: 0,\n                transform: `translateY(${start}px)`,\n                '--level': level,\n            }}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(node, { isExpanded, isExpandable: node.nodes.length > 0 })\n            ) : (\n                <div onClick={() => onItemSelect(node)}>{node.label}</div>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTreeItem.displayName = 'VirtualTreeItem';\n}\n\nconst MemoVirtualTreeItem = memo(VirtualTreeItem, (prev, next) =>\n    // ignore object identity of these props\n    shallowEquals(prev, next, ['measureRef', 'onItemSelect', 'onKeyDown'])\n);\n\nexport default MemoVirtualTreeItem;\n","import { forwardRef, useImperativeHandle, useState, useEffect, memo, useRef, useCallback, useMemo } from 'react';\nimport { useVirtual, defaultRangeExtractor } from 'react-virtual';\nimport PropTypes from 'prop-types';\n\nimport VirtualTreeItem from './VirtualTreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport {\n    internalId,\n    flattenData,\n    getExpandState,\n    getParentNode,\n    getNodeAt,\n    noop,\n    isUndefined,\n    isFn,\n} from '../utils.js';\nimport basePropTypes from '../basePropTypes.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst VirtualTreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        rowHeight = 30,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    const parentRef = useRef();\n    const flattened = useMemo(() => flattenData(nodes, expanded), [nodes, expanded]);\n\n    const rowVirtualizer = useVirtual({\n        estimateSize: useCallback(() => rowHeight, [rowHeight]),\n\n        size: flattened.length,\n        parentRef,\n\n        // prerender the focused item, the one before it, after it, the parent item of the focused one\n        rangeExtractor(range) {\n            const defaultRange = defaultRangeExtractor(range);\n            const focusedIndex = flattened.findIndex((node) => node.id === focused);\n\n            if (focusedIndex === -1) {\n                return defaultRange;\n            } else {\n                let range = new Set(defaultRange);\n\n                const node = flattened[focusedIndex];\n                const parent = getParentNode(nodes, node[internalId]);\n\n                if (parent) {\n                    range.add(flattened.findIndex((node) => node.id === parent.id));\n                }\n\n                if (focusedIndex > 0) {\n                    range.add(focusedIndex - 1);\n                }\n\n                range.add(focusedIndex);\n\n                if (focusedIndex < flattened.length - 1) {\n                    range.add(focusedIndex + 1);\n                }\n\n                return [...range];\n            }\n        },\n    });\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    // this is mostly done to allow users of the component to call `.focus()` from the imperative handle\n    const [counter, setCounter] = useState(0);\n\n    useEffect(() => {\n        if (counter > 0) {\n            const index = flattened.findIndex((node) => node.id === focused);\n            const node = flattened[index];\n            const el = parentRef.current.querySelector(`[data-index=\"${node[internalId]}\"]`);\n\n            rowVirtualizer.scrollToIndex(index);\n\n            if (el) {\n                el.focus();\n            }\n        }\n    }, [counter]);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setCounter((prev) => prev + 1);\n            },\n        };\n    });\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            if (flattened[0].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index - 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            if (flattened[flattened.length - 1].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index + 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable && isExpanded) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const node = flattened[index];\n\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n\n                focusTreeItem(node);\n            } else {\n                const parentNode = getParentNode(nodes, e.currentTarget.dataset.index);\n\n                if (parentNode) {\n                    const index = flattened.findIndex((node) => node.id === parentNode.id);\n                    const node = flattened[index]; // we do this, because parentNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable) {\n                if (isExpanded) {\n                    const childNode = getNodeAt(nodes, e.currentTarget.dataset.index).nodes[0];\n\n                    const index = flattened.findIndex((node) => node.id === childNode.id);\n                    const node = flattened[index]; // we do this, because childNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                } else {\n                    const index = flattened.findIndex((node) => node.id === focused);\n                    const node = flattened[index];\n\n                    setExpanded((prev) => prev.concat(node.id));\n                    onExpandChange(node);\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    const focusTreeItem = (node) => {\n        if (node.id !== focused) {\n            setCounter((prev) => prev + 1);\n            setFocused(node.id);\n            onFocusChange(node);\n\n            if (selectionFollowsFocus) {\n                setSelected(node.id);\n                onSelectChange(node);\n            }\n        }\n    };\n\n    const treeStyles = useMemo(() => {\n        return {\n            height: rowVirtualizer.totalSize + 'px',\n            position: 'relative',\n            margin: 0,\n            padding: 0,\n        };\n    }, [rowVirtualizer.totalSize]);\n\n    return (\n        <div {...rest} ref={parentRef}>\n            <ul role=\"tree\" style={treeStyles}>\n                {rowVirtualizer.virtualItems.map((virtualRow) => {\n                    const node = flattened[virtualRow.index];\n\n                    const path = node[internalId].split('-');\n\n                    const level = path.length;\n                    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n                    const setSize =\n                        path.length === 1 ? nodes.length : getParentNode(nodes, node[internalId]).nodes.length;\n\n                    const isExpandable = node.nodes.length > 0;\n                    const isExpanded = isExpandable ? expanded.includes(node.id) : null;\n\n                    return (\n                        <VirtualTreeItem\n                            key={virtualRow.index}\n                            node={node}\n                            measureRef={virtualRow.measureRef}\n                            start={virtualRow.start}\n                            isExpanded={isExpanded}\n                            isSelected={selected === node.id}\n                            tabIndex={focused === node.id ? 0 : -1}\n                            level={level}\n                            positionInSet={positionInSet}\n                            setSize={setSize}\n                            index={node[internalId]}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    );\n                })}\n            </ul>\n        </div>\n    );\n};\n\nconst VirtualTree = forwardRef(VirtualTreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTree.displayName = 'VirtualTree';\n    VirtualTree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(VirtualTree);\n"],"names":["noop","isFn","value","isUndefined","getNodeAt","nodes","index","path","split","node","i","length","undefined","getParentNode","slice","join","getExpandState","el","ariaExpandedAttribute","getAttribute","isExpandable","isExpanded","isLastTopLevelItem","parseInt","shallowEquals","prev","next","ignored","Object","is","keysPrev","keys","filter","key","includes","keysNext","prototype","hasOwnProperty","call","internalId","Symbol","addInternalIds","parentId","result","push","TreeItem","_ref","selected","focused","expanded","setSize","counter","onItemSelect","renderLabel","onKeyDown","id","positionInSet","useRef","useEffect","current","focus","firstElementChild","scrollIntoView","block","React","ref","role","tabIndex","onClick","label","map","n","childIndex","MemoTreeItem","propsAreEqual","stack","shift","memo","valueProp","defaultValue","valueState","setValueState","useState","isUncontrolled","useCallback","TreeImpl","defaultFocused","focusedProp","onFocusChange","defaultExpanded","expandedProp","onExpandChange","selectionTogglesExpanded","selectionFollowsFocus","defaultSelected","selectedProp","onSelectChange","rest","initialFocus","setFocused","useInternalState","setExpanded","setSelected","setCounter","useImperativeHandle","e","altKey","ctrlKey","metaKey","target","currentTarget","preventDefault","dataset","previousElementSibling","item","lastElementChild","focusTreeItem","parent","nextElementSibling","parentElement","concat","Tree","forwardRef","VirtualTreeItem","measureRef","start","isSelected","level","isFocused","style","position","top","transform","VirtualTreeImpl","rowHeight","parentRef","flattened","useMemo","tree","pop","flattenData","rowVirtualizer","useVirtual","estimateSize","size","rangeExtractor","range","defaultRange","defaultRangeExtractor","focusedIndex","findIndex","Set","add","querySelector","scrollToIndex","parentNode","childNode","treeStyles","height","totalSize","margin","padding","virtualItems","virtualRow","VirtualTree"],"mappings":"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"}