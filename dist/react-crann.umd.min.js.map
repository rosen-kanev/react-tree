{"version":3,"file":"react-crann.umd.min.js","sources":["../src/utils.js","../src/regular/TreeItem.jsx","../src/useInternalState.js","../src/regular/Tree.jsx","../src/virtual/VirtualTreeItem.jsx","../src/virtual/VirtualTree.jsx"],"sourcesContent":["export const noop = () => {};\n\nexport const isFn = (value) => typeof value === 'function';\nexport const isUndefined = (value) => typeof value === 'undefined';\n\nexport const getNodeAt = (nodes, index) => {\n    const path = index.split('-');\n    let node = { nodes };\n    let i = 0;\n\n    while (node != null && i < path.length) {\n        node = node.nodes[path[i++]];\n    }\n\n    return i && i === path.length ? node : undefined;\n};\n\nexport const getParentNode = (nodes, index) => {\n    const path = index.split('-');\n\n    return path.length > 1 ? getNodeAt(nodes, path.slice(0, -1).join('-')) : null;\n};\n\nexport const getExpandState = (el) => {\n    const ariaExpandedAttribute = el.getAttribute('aria-expanded');\n\n    return {\n        isExpandable: ariaExpandedAttribute !== null,\n        isExpanded: ariaExpandedAttribute === 'true',\n    };\n};\n\nexport const isLastTopLevelItem = (nodes, index) => {\n    const path = index.split('-');\n\n    return path.length === 1 && parseInt(path[0], 10) === nodes.length - 1;\n};\n\nexport const shallowEquals = (prev, next, ignored) => {\n    if (Object.is(prev, next)) {\n        return true;\n    }\n\n    const keysPrev = Object.keys(prev).filter((key) => !ignored.includes(key));\n    const keysNext = Object.keys(next).filter((key) => !ignored.includes(key));\n\n    if (keysPrev.length !== keysNext.length) {\n        return false;\n    }\n\n    for (const key of keysPrev) {\n        if (!Object.prototype.hasOwnProperty.call(next, key) || !Object.is(prev[key], next[key])) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nexport const internalId = Symbol('id');\n\nexport const addInternalIds = (nodes, parentId) => {\n    let result = [];\n    let i = nodes.length - 1;\n\n    while (i >= 0) {\n        result.push({\n            ...nodes[i],\n            [internalId]: parentId ? `${parentId}-${i}` : `${i}`,\n        });\n\n        i--;\n    }\n\n    return result;\n};\n\nexport const flattenData = (nodes, expanded) => {\n    const stack = addInternalIds(nodes, '');\n    const tree = [];\n\n    while (stack.length) {\n        const node = stack.pop();\n\n        tree.push(node);\n\n        if (expanded.includes(node.id)) {\n            stack.push(...addInternalIds(node.nodes, node[internalId]));\n        }\n    }\n\n    return tree;\n};\n","import { useCallback, useRef, useEffect, memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst TreeItem = ({\n    node,\n    index,\n    selected,\n    focused,\n    expanded,\n    setSize,\n    counter,\n    needsRefocus,\n    setNeedsRefocus,\n    onItemSelect,\n    renderLabel,\n    onKeyDown,\n}) => {\n    const isExpandable = node.nodes.length > 0;\n    const isExpanded = isExpandable ? expanded.includes(node.id) : null;\n\n    const path = index.split('-');\n    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n\n    const el = useRef();\n\n    const focus = useCallback((reset) => {\n        if (el.current) {\n            el.current.focus();\n            el.current.firstElementChild.scrollIntoView({ block: 'nearest' });\n\n            if (reset) {\n                setNeedsRefocus(false);\n            }\n        }\n    }, []);\n\n    // handles ArrowUp/Down/Left/Right focus management\n    useEffect(() => {\n        // counter > 0 is here only to avoid calling focus() when the component mounts for the first time\n        if (counter > 0 && focused === node.id) {\n            focus();\n        }\n    }, [counter]);\n\n    // handles imperative change of focus\n    useEffect(() => {\n        if (needsRefocus && focused === node.id) {\n            focus(true);\n        }\n    }, [needsRefocus]);\n\n    return (\n        <li\n            ref={el}\n            role=\"treeitem\"\n            tabIndex={focused === node.id ? 0 : -1}\n            aria-expanded={isExpanded}\n            aria-selected={selected === node.id || null}\n            aria-level={path.length}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(node, { isExpandable, isExpanded })\n            ) : (\n                <div onClick={() => onItemSelect(node)}>{node.label}</div>\n            )}\n\n            {isExpanded && isExpandable && (\n                <ul role=\"group\">\n                    {node.nodes.map((n, childIndex) => (\n                        <MemoTreeItem\n                            key={n.id}\n                            node={n}\n                            index={index + '-' + childIndex}\n                            selected={selected}\n                            focused={focused}\n                            expanded={expanded}\n                            setSize={node.nodes.length}\n                            counter={counter}\n                            needsRefocus={needsRefocus}\n                            setNeedsRefocus={setNeedsRefocus}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    ))}\n                </ul>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    TreeItem.displayName = 'TreeItem';\n}\n\nconst propsAreEqual = (prev, next) => {\n    // ignore object identity of these props\n    const ignored = ['counter', 'needsRefocus', 'selected', 'focused', 'expanded', 'onItemSelect', 'onKeyDown'];\n    const areOtherPropsDifferent = !shallowEquals(prev, next, ignored);\n\n    if (areOtherPropsDifferent) {\n        // other props are different - trigger a rerender\n        return false;\n    }\n\n    // breadth first traverse - when working with file system like trees the user usually starts from the outer nodes\n    // and most of the tree changes will be happening near the root of the tree\n    const stack = [{ ...next.node, nodes: [] }, ...next.node.nodes];\n\n    while (stack.length) {\n        const node = stack.shift();\n\n        if (node.id === next.focused || node.id === prev.focused) {\n            // a node or one of its children has to change its `tabIndex` - trigger a rerender\n            return false;\n        }\n\n        if (node.id === next.selected || node.id === prev.selected) {\n            // a node or one of its children has to change its `aria-selected` - trigger a rerender\n            return false;\n        }\n\n        if (prev.expanded.includes(node.id) !== next.expanded.includes(node.id)) {\n            // a node or one of its children has to be collapsed/expanded - trigger a rerender\n            return false;\n        }\n\n        stack.push(...node.nodes);\n    }\n\n    return true;\n};\n\nconst MemoTreeItem = memo(TreeItem, propsAreEqual);\n\nexport default MemoTreeItem;\n","import { useState, useCallback } from 'react';\n\nimport { isUndefined, isFn } from './utils';\n\nconst useInternalState = (valueProp, defaultValue) => {\n    const [valueState, setValueState] = useState(defaultValue);\n    const isUncontrolled = isUndefined(valueProp);\n    const value = isUncontrolled ? valueState : valueProp;\n\n    const updateValue = useCallback(\n        (next) => {\n            if (isUncontrolled) {\n                setValueState(next);\n            }\n        },\n        [isUncontrolled, value]\n    );\n\n    return [value, updateValue];\n};\n\nexport default useInternalState;\n","import { useState, forwardRef, useImperativeHandle, memo } from 'react';\n\nimport TreeItem from './TreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport basePropTypes from '../basePropTypes.js';\n\nimport { isLastTopLevelItem, getExpandState, getParentNode, getNodeAt, noop, isUndefined } from '../utils.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst TreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    const [counter, setCounter] = useState(0);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setNeedsRefocus(true);\n            },\n        };\n    });\n\n    const [needsRefocus, setNeedsRefocus] = useState(false);\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            if (e.currentTarget.dataset.index !== '0') {\n                if (e.currentTarget.previousElementSibling) {\n                    // move back a node and find the deepest leaf node\n                    let item = e.currentTarget.previousElementSibling;\n\n                    while (true) {\n                        const { isExpanded, isExpandable } = getExpandState(item);\n\n                        if (isExpandable && isExpanded) {\n                            // ├─ node_modules\n                            // │  └─ @babel\n                            // │     ├─ code-frame\n                            // │     └─ compat-data (next)\n                            // ├─ src (current)\n                            item = item.lastElementChild.lastElementChild;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    const node = getNodeAt(nodes, item.dataset.index);\n\n                    focusTreeItem(node);\n                } else {\n                    // ├─ node_modules\n                    // │  └─ @babel (next)\n                    // │     ├─ code-frame (current)\n                    // │     └─ compat-data\n                    const parent = getParentNode(nodes, e.currentTarget.dataset.index);\n\n                    if (parent) {\n                        focusTreeItem(parent);\n                    }\n                }\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            const { isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpanded) {\n                // ├─ node_modules (current)\n                // │  └─ @babel (next)\n                // │     ├─ code-frame\n                // │     └─ compat-data\n                // ├─ src\n                const parent = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n                focusTreeItem(parent.nodes[0]);\n            } else {\n                let item = e.currentTarget;\n                // go to parent and find its next sibling until we find a node or reach the end of the tree\n                // ├─ node_modules\n                // │  └─ @babel\n                // │     ├─ code-frame\n                // │     └─ compat-data (current)\n                // ├─ src (next)\n                while (true) {\n                    // ├─ node_modules\n                    // │  └─ @babel\n                    // │     ├─ code-frame\n                    // │     └─ compat-data (current)\n                    if (isLastTopLevelItem(nodes, item.dataset.index)) {\n                        // we are at the end of the tree\n                        break;\n                    }\n\n                    if (item.nextElementSibling) {\n                        item = item.nextElementSibling;\n                        break;\n                    }\n\n                    item = item.parentElement.parentElement;\n                }\n\n                if (item !== e.currentTarget) {\n                    focusTreeItem(getNodeAt(nodes, item.dataset.index));\n                }\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable && isExpanded) {\n                // ├─ src (current)\n                // │ ├─ App.jsx\n                // │ └─ data.js       -> ├─ src (next)\n                // ├─ .editorconfig      ├─ .editorconfig\n                // └─ .gitignore.js      └─ .gitignore.js\n                const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n            } else {\n                // ├─ src (next)\n                // │ ├─ App.jsx\n                // │ └─ data.js (current)\n                // ├─ .editorconfig\n                // └─ .gitignore.js\n                const parent = getParentNode(nodes, e.currentTarget.dataset.index);\n\n                if (parent) {\n                    focusTreeItem(parent);\n                }\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable) {\n                const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n                if (isExpanded) {\n                    // ├─ src (current)\n                    // │ ├─ App.jsx (next)\n                    // │ └─ data.js\n                    // ├─ .editorconfig\n                    // └─ .gitignore.js\n                    const next = node.nodes[0];\n\n                    focusTreeItem(next);\n                } else {\n                    // ├─ src (current)      ├─ src (next)\n                    // ├─ .editorconfig      │ ├─ App.jsx\n                    // └─ .gitignore.js   -> │ └─ data.js\n                    //                       ├─ .editorconfig\n                    //                       └─ .gitignore.js\n                    setExpanded((prev) => prev.concat(node.id));\n                    onExpandChange(node);\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    const focusTreeItem = (node) => {\n        if (node.id !== focused) {\n            setCounter((prev) => prev + 1);\n            setFocused(node.id);\n            onFocusChange(node);\n\n            if (selectionFollowsFocus) {\n                setSelected(node.id);\n                onSelectChange(node);\n            }\n        }\n    };\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    return (\n        <ul role=\"tree\" {...rest}>\n            {nodes.map((node, index) => (\n                <TreeItem\n                    key={node.id}\n                    node={node}\n                    index={`${index}`}\n                    selected={selected}\n                    focused={focused}\n                    expanded={expanded}\n                    setSize={nodes.length}\n                    counter={counter}\n                    needsRefocus={needsRefocus}\n                    setNeedsRefocus={setNeedsRefocus}\n                    renderLabel={renderLabel}\n                    onItemSelect={onItemSelect}\n                    onKeyDown={onKeyDown}\n                />\n            ))}\n        </ul>\n    );\n};\n\nconst Tree = forwardRef(TreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    Tree.displayName = 'Tree';\n    Tree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(Tree);\n","import { memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst VirtualTreeItem = ({\n    node,\n\n    measureRef,\n    start,\n\n    isExpanded,\n    isSelected,\n\n    tabIndex,\n    level,\n    positionInSet,\n    setSize,\n\n    index,\n    counter,\n    isFocused,\n\n    renderLabel,\n    onItemSelect,\n    onKeyDown,\n}) => {\n    return (\n        <li\n            ref={measureRef}\n            role=\"treeitem\"\n            tabIndex={tabIndex}\n            aria-expanded={isExpanded}\n            aria-selected={isSelected || null}\n            aria-level={level}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            style={{\n                position: 'absolute',\n                top: 0,\n                transform: `translateY(${start}px)`,\n                '--level': level,\n            }}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(node, { isExpanded, isExpandable: node.nodes.length > 0 })\n            ) : (\n                <div onClick={() => onItemSelect(node)}>{node.label}</div>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTreeItem.displayName = 'VirtualTreeItem';\n}\n\nconst MemoVirtualTreeItem = memo(VirtualTreeItem, (prev, next) =>\n    // ignore object identity of these props\n    shallowEquals(prev, next, ['measureRef', 'onItemSelect', 'onKeyDown'])\n);\n\nexport default MemoVirtualTreeItem;\n","import { forwardRef, useImperativeHandle, useState, useEffect, memo, useRef, useCallback, useMemo } from 'react';\nimport { useVirtual, defaultRangeExtractor } from 'react-virtual';\nimport PropTypes from 'prop-types';\n\nimport VirtualTreeItem from './VirtualTreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport {\n    internalId,\n    flattenData,\n    getExpandState,\n    getParentNode,\n    getNodeAt,\n    noop,\n    isUndefined,\n    isFn,\n} from '../utils.js';\nimport basePropTypes from '../basePropTypes.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst VirtualTreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        rowHeight = 30,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    const parentRef = useRef();\n    const flattened = useMemo(() => flattenData(nodes, expanded), [nodes, expanded]);\n\n    const rowVirtualizer = useVirtual({\n        estimateSize: useCallback(() => rowHeight, [rowHeight]),\n\n        size: flattened.length,\n        parentRef,\n\n        // prerender the focused item, the one before it, after it, the parent item of the focused one\n        rangeExtractor(range) {\n            const defaultRange = defaultRangeExtractor(range);\n            const focusedIndex = flattened.findIndex((node) => node.id === focused);\n\n            if (focusedIndex === -1) {\n                return defaultRange;\n            } else {\n                let range = new Set(defaultRange);\n\n                const node = flattened[focusedIndex];\n                const parent = getParentNode(nodes, node[internalId]);\n\n                if (parent) {\n                    range.add(flattened.findIndex((node) => node.id === parent.id));\n                }\n\n                if (focusedIndex > 0) {\n                    range.add(focusedIndex - 1);\n                }\n\n                range.add(focusedIndex);\n\n                if (focusedIndex < flattened.length - 1) {\n                    range.add(focusedIndex + 1);\n                }\n\n                return [...range];\n            }\n        },\n    });\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    // this is mostly done to allow users of the component to call `.focus()` from the imperative handle\n    const [counter, setCounter] = useState(0);\n\n    useEffect(() => {\n        if (counter > 0) {\n            const index = flattened.findIndex((node) => node.id === focused);\n            const node = flattened[index];\n            const el = parentRef.current.querySelector(`[data-index=\"${node[internalId]}\"]`);\n\n            rowVirtualizer.scrollToIndex(index);\n\n            if (el) {\n                el.focus();\n            }\n        }\n    }, [counter]);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setCounter((prev) => prev + 1);\n            },\n        };\n    });\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            if (flattened[0].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index - 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            if (flattened[flattened.length - 1].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index + 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable && isExpanded) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const node = flattened[index];\n\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n\n                focusTreeItem(node);\n            } else {\n                const parentNode = getParentNode(nodes, e.currentTarget.dataset.index);\n\n                if (parentNode) {\n                    const index = flattened.findIndex((node) => node.id === parentNode.id);\n                    const node = flattened[index]; // we do this, because parentNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable) {\n                if (isExpanded) {\n                    const childNode = getNodeAt(nodes, e.currentTarget.dataset.index).nodes[0];\n\n                    const index = flattened.findIndex((node) => node.id === childNode.id);\n                    const node = flattened[index]; // we do this, because childNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                } else {\n                    const index = flattened.findIndex((node) => node.id === focused);\n                    const node = flattened[index];\n\n                    setExpanded((prev) => prev.concat(node.id));\n                    onExpandChange(node);\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    const focusTreeItem = (node) => {\n        if (node.id !== focused) {\n            setCounter((prev) => prev + 1);\n            setFocused(node.id);\n            onFocusChange(node);\n\n            if (selectionFollowsFocus) {\n                setSelected(node.id);\n                onSelectChange(node);\n            }\n        }\n    };\n\n    const treeStyles = useMemo(() => {\n        return {\n            height: rowVirtualizer.totalSize + 'px',\n            position: 'relative',\n            margin: 0,\n            padding: 0,\n        };\n    }, [rowVirtualizer.totalSize]);\n\n    return (\n        <div {...rest} ref={parentRef}>\n            <ul role=\"tree\" style={treeStyles}>\n                {rowVirtualizer.virtualItems.map((virtualRow) => {\n                    const node = flattened[virtualRow.index];\n\n                    const path = node[internalId].split('-');\n\n                    const level = path.length;\n                    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n                    const setSize =\n                        path.length === 1 ? nodes.length : getParentNode(nodes, node[internalId]).nodes.length;\n\n                    const isExpandable = node.nodes.length > 0;\n                    const isExpanded = isExpandable ? expanded.includes(node.id) : null;\n\n                    return (\n                        <VirtualTreeItem\n                            key={virtualRow.index}\n                            node={node}\n                            measureRef={virtualRow.measureRef}\n                            start={virtualRow.start}\n                            isExpanded={isExpanded}\n                            isSelected={selected === node.id}\n                            tabIndex={focused === node.id ? 0 : -1}\n                            level={level}\n                            positionInSet={positionInSet}\n                            setSize={setSize}\n                            index={node[internalId]}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    );\n                })}\n            </ul>\n        </div>\n    );\n};\n\nconst VirtualTree = forwardRef(VirtualTreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTree.displayName = 'VirtualTree';\n    VirtualTree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(VirtualTree);\n"],"names":["noop","isFn","value","isUndefined","getNodeAt","nodes","index","path","split","node","i","length","undefined","getParentNode","slice","join","getExpandState","el","ariaExpandedAttribute","getAttribute","isExpandable","isExpanded","isLastTopLevelItem","parseInt","shallowEquals","prev","next","ignored","Object","is","keysPrev","keys","filter","key","includes","keysNext","prototype","hasOwnProperty","call","internalId","Symbol","addInternalIds","parentId","result","push","TreeItem","_ref","selected","focused","expanded","setSize","counter","needsRefocus","setNeedsRefocus","onItemSelect","renderLabel","onKeyDown","id","positionInSet","useRef","focus","useCallback","reset","current","firstElementChild","scrollIntoView","block","useEffect","React","ref","role","tabIndex","onClick","label","map","n","childIndex","MemoTreeItem","propsAreEqual","stack","shift","memo","valueProp","defaultValue","valueState","setValueState","useState","isUncontrolled","TreeImpl","defaultFocused","focusedProp","onFocusChange","defaultExpanded","expandedProp","onExpandChange","selectionTogglesExpanded","selectionFollowsFocus","defaultSelected","selectedProp","onSelectChange","rest","initialFocus","setFocused","useInternalState","setExpanded","setSelected","setCounter","useImperativeHandle","e","altKey","ctrlKey","metaKey","target","currentTarget","preventDefault","dataset","previousElementSibling","item","lastElementChild","focusTreeItem","parent","nextElementSibling","parentElement","concat","Tree","forwardRef","VirtualTreeItem","measureRef","start","isSelected","level","isFocused","style","position","top","transform","VirtualTreeImpl","rowHeight","parentRef","flattened","useMemo","tree","pop","flattenData","rowVirtualizer","useVirtual","estimateSize","size","rangeExtractor","range","defaultRange","defaultRangeExtractor","focusedIndex","findIndex","Set","add","querySelector","scrollToIndex","parentNode","childNode","treeStyles","height","totalSize","margin","padding","virtualItems","virtualRow","VirtualTree"],"mappings":"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"}