{"version":3,"file":"react-tree.umd.min.js","sources":["../src/utils.js","../src/TreeItem.jsx","../src/useInternalState.js","../src/Tree.jsx"],"sourcesContent":["export const noop = () => {};\n\nexport const isFn = (value) => typeof value === 'function';\nexport const isUndefined = (value) => typeof value === 'undefined';\n\nexport const getNodeIds = (nodes) => {\n    const stack = [...nodes];\n    const result = [];\n\n    while (stack.length) {\n        const node = stack.pop();\n\n        result.push(node.id);\n        stack.push(...node.nodes);\n    }\n\n    return result;\n};\n\nexport const findNode = (nodes, id) => {\n    const stack = [...nodes];\n\n    while (stack.length) {\n        const node = stack.pop();\n\n        if (node.id === id) {\n            return node;\n        }\n\n        stack.push(...node.nodes);\n    }\n\n    return null;\n};\n\n// shallow equals check, but without `expanded` and `onItemSelect`\nexport const shallowEquals = (prev, next) => {\n    if (Object.is(prev, next)) {\n        return true;\n    }\n\n    const keysPrev = Object.keys(prev).filter((key) => key !== 'expanded' && key !== 'onItemSelect');\n    const keysNext = Object.keys(next).filter((key) => key !== 'expanded' && key !== 'onItemSelect');\n\n    if (keysPrev.length !== keysNext.length) {\n        return false;\n    }\n\n    for (const key of keysPrev) {\n        if (!Object.prototype.hasOwnProperty.call(next, key) || !Object.is(prev[key], next[key])) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nexport const propsAreEqual = (prev, next) => {\n    const id = next.id;\n    const areOtherPropsDifferent = !shallowEquals(prev, next);\n\n    if (areOtherPropsDifferent) {\n        return false;\n    }\n\n    if (prev.expanded.includes(id) !== next.expanded.includes(id)) {\n        return false;\n    }\n\n    // We don't do a check if prev.expanded has children to update, because this node won't render any children.\n    // This way we can skip the checks for it and its children - they won't render either way...\n    if (next.expanded.includes(id)) {\n        // this node has children that may need updates\n        const children = getNodeIds(next.nodes);\n\n        for (const child of children) {\n            if (prev.expanded.includes(child) !== next.expanded.includes(child)) {\n                // a child node needs to be updated\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n","import React from 'react';\n\nimport { propsAreEqual, isFn } from './utils';\n\nconst TreeItem = ({ onItemSelect, renderLabel, expanded, ...props }) => {\n    const isExpandable = props.nodes.length > 0;\n    const isExpanded = isExpandable ? expanded.includes(props.id) : null;\n\n    return (\n        <li role=\"treeitem\" tabIndex={-1} aria-expanded={isExpanded} data-id={`treeitem-${props.id}`}>\n            {isFn(renderLabel) ? (\n                renderLabel({\n                    ...props,\n                    isExpanded,\n                    isExpandable,\n                    toggleItem() {\n                        onItemSelect(props.id, isExpandable);\n                    },\n                })\n            ) : (\n                <div onClick={() => onItemSelect(props.id, isExpandable)}>{props.label}</div>\n            )}\n\n            {isExpanded && isExpandable && (\n                <ul role=\"group\">\n                    {props.nodes.map((node) => (\n                        <MemoTreeItem\n                            {...node}\n                            expanded={expanded}\n                            onItemSelect={onItemSelect}\n                            renderLabel={renderLabel}\n                            key={node.id}\n                        />\n                    ))}\n                </ul>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    TreeItem.displayName = 'TreeItem';\n}\n\nconst MemoTreeItem = React.memo(TreeItem, propsAreEqual);\n\nexport default MemoTreeItem;\n","import { useState, useCallback } from 'react';\n\nimport { isUndefined, isFn } from './utils';\n\nconst useInternalState = (valueProp, defaultValue) => {\n    const [valueState, setValueState] = useState(defaultValue);\n    const isUncontrolled = isUndefined(valueProp);\n    const value = isUncontrolled ? valueState : valueProp;\n\n    const updateValue = useCallback(\n        (next) => {\n            if (isUncontrolled) {\n                setValueState(next);\n            }\n        },\n        [isUncontrolled, value]\n    );\n\n    return [value, updateValue];\n};\n\nexport default useInternalState;\n","import React, { useEffect, useCallback, useRef, memo } from 'react';\nimport PropTypes from 'prop-types';\n\nimport TreeItem from './TreeItem.jsx';\nimport useInternalState from './useInternalState.js';\n\nimport { findNode, noop, isUndefined } from './utils';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst Tree = ({\n    nodes,\n\n    defaultFocused,\n    focused: focusedProp,\n    onFocusChange = noop,\n\n    defaultExpanded = [],\n    expanded: expandedProp,\n    onExpandChange = noop,\n\n    defaultSelected,\n    selected: selectedProp,\n    onSelectChange = noop,\n\n    renderLabel,\n    expandOnSelect = true,\n    ...rest\n}) => {\n    const rootEl = useRef(null);\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    useEffect(() => {\n        // remove tabIndex from previous and add it to current\n        const node = rootEl.current.querySelector(`[data-id=\"treeitem-${focused}\"]`);\n        const oldNode = rootEl.current.querySelector(`[tabindex=\"0\"]`);\n\n        if (oldNode) {\n            oldNode.setAttribute('tabindex', '-1');\n        }\n\n        /* istanbul ignore next when nodes is empty it's okay not to have a focused element */\n        if (node) {\n            node.setAttribute('tabindex', '0');\n        }\n    }, [focused]);\n\n    useEffect(() => {\n        // remove aria-selected from previous and add it to current\n        const node = rootEl.current.querySelector(`[data-id=\"treeitem-${selected}\"]`);\n        const oldNode = rootEl.current.querySelector(`[aria-selected=\"true\"]`);\n\n        if (oldNode) {\n            oldNode.removeAttribute('aria-selected');\n        }\n\n        // selected node is optional so we don't show a warning if no node is found\n        if (node) {\n            node.setAttribute('aria-selected', 'true');\n        }\n    }, [selected]);\n\n    // This function is passed as a prop to <TreeItem />, but it has custom `memo(arePropsEqual)`\n    // which ignores object identity changes. If the `memo()` changes make sure to wrap this with `useCallback()`\n    const onItemSelect = (id, isExpandable) => {\n        const node = findNode(nodes, id);\n\n        if (expandOnSelect && isExpandable) {\n            setExpanded((prev) => {\n                return prev.includes(id) ? prev.filter((node) => node !== id) : prev.concat(id);\n            });\n            onExpandChange(node);\n        }\n\n        setFocused(id);\n        onFocusChange(node);\n\n        setSelected(id);\n        onSelectChange(node);\n    };\n\n    const moveToTreeItem = (isPrev) => {\n        const items = rootEl.current.querySelectorAll('[role=\"treeitem\"]');\n\n        let nextNode;\n        for (let i = 0; i < items.length; i++) {\n            const element = items[i];\n\n            if (element.tabIndex === 0) {\n                nextNode = isPrev ? items[i - 1] : items[i + 1];\n                break;\n            }\n        }\n\n        if (nextNode) {\n            const id = nextNode.dataset.id.replace('treeitem-', '');\n            const node = findNode(nodes, id);\n\n            setFocused(id);\n            onFocusChange(node);\n\n            nextNode.focus();\n            nextNode.firstElementChild.scrollIntoView({ block: 'center' });\n        }\n    };\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            // move to previous node that is visible on the screen\n            moveToTreeItem(true);\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            // move to next node that is visible on the screen\n            moveToTreeItem(false);\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const { treeItem, isExpandable, isExpanded } = getTreeItem(focused);\n\n            if (isExpandable && isExpanded) {\n                // close node\n                const node = findNode(nodes, focused);\n\n                setExpanded((prev) => prev.filter((node) => node !== focused));\n                onExpandChange(node);\n            } else {\n                // move focus to parent node\n                focusItem(treeItem.closest('[role=\"treeitem\"]:not([tabindex=\"0\"])'));\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const { treeItem, isExpandable, isExpanded } = getTreeItem(focused);\n\n            if (isExpandable) {\n                if (isExpanded) {\n                    // move focus to next child node\n                    focusItem(treeItem.querySelector('[role=\"treeitem\"]'));\n                } else {\n                    // open node\n                    const node = findNode(nodes, focused);\n\n                    setExpanded((prev) => prev.concat(focused));\n                    onExpandChange(node);\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const isExpandable = rootEl.current\n                .querySelector(`[data-id=\"treeitem-${focused}\"]`)\n                .hasAttribute('aria-expanded');\n\n            onItemSelect(focused, isExpandable);\n        }\n    };\n\n    const getTreeItem = (id) => {\n        const treeItem = rootEl.current.querySelector(`[data-id=\"treeitem-${id}\"]`);\n\n        return {\n            treeItem,\n            isExpandable: treeItem.hasAttribute('aria-expanded'),\n            isExpanded: treeItem.getAttribute('aria-expanded') === 'true',\n        };\n    };\n\n    const focusItem = (item) => {\n        if (item) {\n            item.focus();\n            item.firstElementChild.scrollIntoView({ block: 'center' });\n\n            const id = item.dataset.id.replace('treeitem-', '');\n            const node = findNode(nodes, id);\n\n            setFocused(id);\n            onFocusChange(node);\n        }\n    };\n\n    return (\n        <ul role=\"tree\" onKeyDown={onKeyDown} {...rest} ref={rootEl}>\n            {nodes.map((node) => (\n                <TreeItem\n                    {...node}\n                    expanded={expanded}\n                    onItemSelect={onItemSelect}\n                    renderLabel={renderLabel}\n                    key={node.id}\n                />\n            ))}\n        </ul>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    const getErrorForControlled = (propName, componentName, handlerName, defaultPropName) => {\n        return (\n            `You provided a \\`${propName}\\` prop to ${componentName} without an \\`${handlerName}\\` handler. ` +\n            `This will cause the ${componentName} component to behave incorrectly. ` +\n            `If the ${componentName} should be mutable use \\`${defaultPropName}\\` instead. Otherwise, set \\`${handlerName}\\`.`\n        );\n    };\n\n    const getErrorForUncontrolled = (propName, componentName, handlerName, defaultPropName) => {\n        return (\n            `You provided a \\`${propName}\\` prop as well as a \\`${defaultPropName}\\` prop to ${componentName}. ` +\n            `If you want a controlled component, use the \\`${propName}\\` prop with an \\`${handlerName}\\` handler. ` +\n            `If you want an uncontrolled component, remove the \\`${propName}\\` prop and use \\`${defaultPropName}\\` instead.`\n        );\n    };\n\n    const getGenericTypeError = (name, componentName, expectedType, value) => {\n        return `Invalid prop \\`${name}\\` supplied to ${componentName}. Expected \\`${expectedType}\\`, received \\`${\n            Array.isArray(value) ? 'array' : typeof value\n        }\\`.`;\n    };\n\n    let nodeShape = {\n        id: PropTypes.string.isRequired,\n        label: PropTypes.oneOfType([PropTypes.string, PropTypes.node]).isRequired,\n    };\n    nodeShape.nodes = PropTypes.arrayOf(PropTypes.shape(nodeShape));\n\n    Tree.displayName = 'Tree';\n    Tree.propTypes = {\n        nodes: PropTypes.arrayOf(PropTypes.shape(nodeShape)).isRequired,\n\n        defaultFocused: PropTypes.string,\n        focused: (props, name, componentName) => {\n            const value = props[name];\n            const comp = `\\`<${componentName}>\\``;\n\n            if (typeof value === 'string' && props.onFocusChange == null) {\n                return new Error(getErrorForControlled(name, comp, 'onFocusChange', 'defaultFocused'));\n            }\n\n            if (value != null && props.defaultFocused != null) {\n                return new Error(getErrorForUncontrolled(name, comp, 'onFocusChange', 'defaultFocused'));\n            }\n\n            if (value != null && typeof value !== 'string') {\n                return new Error(getGenericTypeError(name, comp, 'string', value));\n            }\n\n            return null;\n        },\n        onFocusChange: PropTypes.func,\n\n        defaultExpanded: PropTypes.arrayOf(PropTypes.string),\n        expanded: (props, name, componentName) => {\n            const value = props[name];\n            const comp = `\\`<${componentName}>\\``;\n\n            if (Array.isArray(value) && props.onExpandChange == null) {\n                return new Error(getErrorForControlled(name, comp, 'onExpandChange', 'defaultExpanded'));\n            }\n\n            if (value != null && props.defaultExpanded != null) {\n                return new Error(getErrorForUncontrolled(name, comp, 'onExpandChange', 'defaultExpanded'));\n            }\n\n            if (Array.isArray(value)) {\n                const message = `You provided an array as \\`${name}\\` in ${comp} but one or more of the values are not string.`;\n\n                return value.some((i) => typeof i !== 'string') ? new Error(message) : null;\n            }\n\n            if (value != null && !Array.isArray(value)) {\n                return new Error(getGenericTypeError(name, comp, 'array', value));\n            }\n\n            return null;\n        },\n        onExpandChange: PropTypes.func,\n\n        defaultSelected: PropTypes.string,\n        selected: (props, name, componentName, location) => {\n            const value = props[name];\n            const comp = `\\`<${componentName}>\\``;\n\n            if (typeof value === 'string' && props.onSelectChange == null) {\n                return new Error(getErrorForControlled(name, comp, 'onSelectChange', 'defaultSelected'));\n            }\n\n            if (value != null && props.defaultSelected != null) {\n                return new Error(getErrorForUncontrolled(name, comp, 'onSelectChange', 'defaultSelected'));\n            }\n\n            if (value != null && typeof value !== 'string') {\n                return new Error(getGenericTypeError(name, comp, 'string', value));\n            }\n\n            return null;\n        },\n        onSelectChange: PropTypes.func,\n\n        renderLabel: PropTypes.func,\n    };\n}\n\nexport default memo(Tree);\n"],"names":["noop","isUndefined","value","findNode","nodes","id","stack","length","node","pop","push","propsAreEqual","prev","next","Object","is","keysPrev","keys","filter","key","keysNext","prototype","hasOwnProperty","call","shallowEquals","expanded","includes","children","result","getNodeIds","child","TreeItem","onItemSelect","renderLabel","props","isExpandable","isExpanded","React","role","tabIndex","toggleItem","onClick","label","map","MemoTreeItem","memo","useInternalState","valueProp","defaultValue","valueState","setValueState","useState","isUncontrolled","useCallback","Tree","defaultFocused","focused","focusedProp","onFocusChange","defaultExpanded","expandedProp","onExpandChange","defaultSelected","selected","selectedProp","onSelectChange","expandOnSelect","rest","rootEl","useRef","initialFocus","undefined","setFocused","setExpanded","setSelected","useEffect","current","querySelector","oldNode","setAttribute","removeAttribute","concat","moveToTreeItem","isPrev","items","querySelectorAll","nextNode","i","dataset","replace","focus","firstElementChild","scrollIntoView","block","getTreeItem","treeItem","hasAttribute","getAttribute","focusItem","item","onKeyDown","e","altKey","ctrlKey","metaKey","preventDefault","closest","ref"],"mappings":"ilBAAO,MAAMA,EAAO,OAGPC,EAAeC,QAA2B,IAAVA,EAgBhCC,EAAW,CAACC,EAAOC,WACtBC,EAAQ,IAAIF,QAEXE,EAAMC,QAAQ,OACXC,EAAOF,EAAMG,SAEfD,EAAKH,KAAOA,SACLG,EAGXF,EAAMI,QAAQF,EAAKJ,cAGhB,MAyBEO,EAAgB,CAACC,EAAMC,WAC1BR,EAAKQ,EAAKR,OAtBS,EAACO,EAAMC,QAC5BC,OAAOC,GAAGH,EAAMC,UACT,QAGLG,EAAWF,OAAOG,KAAKL,GAAMM,QAAQC,GAAgB,aAARA,GAA8B,iBAARA,IACnEC,EAAWN,OAAOG,KAAKJ,GAAMK,QAAQC,GAAgB,aAARA,GAA8B,iBAARA,OAErEH,EAAST,SAAWa,EAASb,cACtB,MAGN,MAAMY,KAAOH,MACTF,OAAOO,UAAUC,eAAeC,KAAKV,EAAMM,KAASL,OAAOC,GAAGH,EAAKO,GAAMN,EAAKM,WACxE,SAIR,GAKyBK,CAAcZ,EAAMC,UAGzC,KAGPD,EAAKa,SAASC,SAASrB,KAAQQ,EAAKY,SAASC,SAASrB,UAC/C,KAKPQ,EAAKY,SAASC,SAASrB,GAAK,OAEtBsB,EApEavB,CAAAA,UACjBE,EAAQ,IAAIF,GACZwB,EAAS,QAERtB,EAAMC,QAAQ,OACXC,EAAOF,EAAMG,MAEnBmB,EAAOlB,KAAKF,EAAKH,IACjBC,EAAMI,QAAQF,EAAKJ,cAGhBwB,GAyDcC,CAAWhB,EAAKT,WAE5B,MAAM0B,KAASH,KACZf,EAAKa,SAASC,SAASI,KAAWjB,EAAKY,SAASC,SAASI,UAElD,SAKZ,GC/ELC,EAAW,EAAGC,aAAAA,EAAcC,YAAAA,EAAaR,SAAAA,KAAaS,YAClDC,EAAeD,EAAM9B,MAAMG,OAAS,EACpC6B,EAAaD,EAAeV,EAASC,SAASQ,EAAM7B,IAAM,YAG5DgC,8BAAIC,KAAK,WAAWC,UAAW,kBAAkBH,YAAsB,YAAWF,EAAM7B,MDPhD,mBCQ9B4B,EACFA,EAAY,IACLC,EACHE,WAAAA,EACAD,aAAAA,EACAK,aACIR,EAAaE,EAAM7B,GAAI8B,MAI/BE,+BAAKI,QAAS,IAAMT,EAAaE,EAAM7B,GAAI8B,IAAgBD,EAAMQ,OAGpEN,GAAcD,GACXE,8BAAIC,KAAK,SACJJ,EAAM9B,MAAMuC,KAAKnC,GACd6B,wBAACO,OACOpC,GACJiB,SAAUA,EACVO,aAAcA,EACdC,YAAaA,EACbd,IAAKX,EAAKH,WAchCuC,EAAeP,UAAMQ,KAAKd,EAAUpB,GCzCpCmC,EAAmB,CAACC,EAAWC,WAC1BC,EAAYC,GAAiBC,WAASH,GACvCI,EAAiBnD,EAAY8C,GAC7B7C,EAAQkD,EAAiBH,EAAaF,QAWrC,CAAC7C,EATYmD,eACfxC,IACOuC,GACAF,EAAcrC,KAGtB,CAACuC,EAAgBlD,MCFnBoD,EAAO,EACTlD,MAAAA,EAEAmD,eAAAA,EACAC,QAASC,EACTC,cAAAA,EAAgB1D,EAEhB2D,gBAAAA,EAAkB,GAClBlC,SAAUmC,EACVC,eAAAA,EAAiB7D,EAEjB8D,gBAAAA,EACAC,SAAUC,EACVC,eAAAA,EAAiBjE,EAEjBiC,YAAAA,EACAiC,eAAAA,GAAiB,KACdC,YAEGC,EAASC,SAAO,MAChBC,EAAerE,EAAYwD,GAC3BxD,EAAYsD,IAAmBnD,EAAMG,OAAS,EAC1CH,EAAM,GAAGC,GACTkD,OACJgB,GAECf,EAASgB,GAAc1B,EAAiBW,EAAaa,IACrD7C,EAAUgD,GAAe3B,EAAiBc,EAAcD,IACxDI,EAAUW,GAAe5B,EAAiBkB,EAAcF,GAE/Da,aAAU,WAEAnE,EAAO4D,EAAOQ,QAAQC,cAAe,sBAAqBrB,OAC1DsB,EAAUV,EAAOQ,QAAQC,cAAe,kBAE1CC,GACAA,EAAQC,aAAa,WAAY,MAIjCvE,GACAA,EAAKuE,aAAa,WAAY,OAEnC,CAACvB,IAEJmB,aAAU,WAEAnE,EAAO4D,EAAOQ,QAAQC,cAAe,sBAAqBd,OAC1De,EAAUV,EAAOQ,QAAQC,cAAe,0BAE1CC,GACAA,EAAQE,gBAAgB,iBAIxBxE,GACAA,EAAKuE,aAAa,gBAAiB,UAExC,CAAChB,UAIE/B,EAAe,CAAC3B,EAAI8B,WAChB3B,EAAOL,EAASC,EAAOC,GAEzB6D,GAAkB/B,IAClBsC,GAAa7D,GACFA,EAAKc,SAASrB,GAAMO,EAAKM,QAAQV,GAASA,IAASH,IAAMO,EAAKqE,OAAO5E,KAEhFwD,EAAerD,IAGnBgE,EAAWnE,GACXqD,EAAclD,GAEdkE,EAAYrE,GACZ4D,EAAezD,IAGb0E,EAAkBC,UACdC,EAAQhB,EAAOQ,QAAQS,iBAAiB,yBAE1CC,MACC,IAAIC,EAAI,EAAGA,EAAIH,EAAM7E,OAAQgF,IAAK,IAGV,IAFTH,EAAMG,GAEVhD,SAAgB,CACxB+C,EAAWH,EAASC,EAAMG,EAAI,GAAKH,EAAMG,EAAI,aAKjDD,EAAU,OACJjF,EAAKiF,EAASE,QAAQnF,GAAGoF,QAAQ,YAAa,IAC9CjF,EAAOL,EAASC,EAAOC,GAE7BmE,EAAWnE,GACXqD,EAAclD,GAEd8E,EAASI,QACTJ,EAASK,kBAAkBC,eAAe,CAAEC,MAAO,aA+DrDC,EAAezF,UACX0F,EAAW3B,EAAOQ,QAAQC,cAAe,sBAAqBxE,aAE7D,CACH0F,SAAAA,EACA5D,aAAc4D,EAASC,aAAa,iBACpC5D,WAAuD,SAA3C2D,EAASE,aAAa,mBAIpCC,EAAaC,OACXA,EAAM,CACNA,EAAKT,QACLS,EAAKR,kBAAkBC,eAAe,CAAEC,MAAO,iBAEzCxF,EAAK8F,EAAKX,QAAQnF,GAAGoF,QAAQ,YAAa,IAC1CjF,EAAOL,EAASC,EAAOC,GAE7BmE,EAAWnE,GACXqD,EAAclD,YAKlB6B,gCAAIC,KAAK,OAAO8D,UAnFDC,OAEVjG,EAAMG,SAAU8F,EAAEC,SAAUD,EAAEE,UAAWF,EAAEG,WAIlC,YAAVH,EAAElF,IACFkF,EAAEI,iBAGFvB,GAAe,QACZ,GAAc,cAAVmB,EAAElF,IACTkF,EAAEI,iBAGFvB,GAAe,QACZ,GAAc,cAAVmB,EAAElF,IAAqB,CAC9BkF,EAAEI,uBAEIV,SAAEA,EAAF5D,aAAYA,EAAZC,WAA0BA,GAAe0D,EAAYtC,MAEvDrB,GAAgBC,EAAY,OAEtB5B,EAAOL,EAASC,EAAOoD,GAE7BiB,GAAa7D,GAASA,EAAKM,QAAQV,GAASA,IAASgD,MACrDK,EAAerD,QAGf0F,EAAUH,EAASW,QAAQ,+CAE5B,GAAc,eAAVL,EAAElF,IAAsB,CAC/BkF,EAAEI,uBAEIV,SAAEA,EAAF5D,aAAYA,EAAZC,WAA0BA,GAAe0D,EAAYtC,MAEvDrB,KACIC,EAEA8D,EAAUH,EAASlB,cAAc,0BAC9B,OAEGrE,EAAOL,EAASC,EAAOoD,GAE7BiB,GAAa7D,GAASA,EAAKqE,OAAOzB,KAClCK,EAAerD,SAGpB,GAAc,UAAV6F,EAAElF,KAA6B,MAAVkF,EAAElF,IAAa,CAC3CkF,EAAEI,uBAEItE,EAAeiC,EAAOQ,QACvBC,cAAe,sBAAqBrB,OACpCwC,aAAa,iBAElBhE,EAAawB,EAASrB,MA4BgBgC,GAAMwC,IAAKvC,IAChDhE,EAAMuC,KAAKnC,GACR6B,wBAACN,OACOvB,GACJiB,SAAUA,EACVO,aAAcA,EACdC,YAAaA,EACbd,IAAKX,EAAKH,iBAkHfwC,OAAKS"}