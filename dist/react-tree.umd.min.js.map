{"version":3,"file":"react-tree.umd.min.js","sources":["../src/utils.js","../src/regular/TreeItem.jsx","../src/useInternalState.js","../src/regular/Tree.jsx","../src/virtual/VirtualTreeItem.jsx","../src/virtual/VirtualTree.jsx"],"sourcesContent":["export const noop = () => {};\n\nexport const isFn = (value) => typeof value === 'function';\nexport const isUndefined = (value) => typeof value === 'undefined';\n\nexport const getNodeAt = (nodes, index) => {\n    const path = index.split('-');\n    let node = { nodes };\n    let i = 0;\n\n    while (node != null && i < path.length) {\n        node = node.nodes[path[i++]];\n    }\n\n    return i && i === path.length ? node : undefined;\n};\n\nexport const moveUp = (current, nodes) => {\n    if (current.dataset.index === '0') {\n        // we are at the start of the tree\n        return [null, null];\n    }\n\n    if (current.previousElementSibling) {\n        // move back a node and find the deepest leaf node\n        let item = current.previousElementSibling;\n\n        while (true) {\n            const { isExpanded, isExpandable } = getExpandState(item);\n\n            if (isExpandable && isExpanded) {\n                // ├─ node_modules\n                // │  └─ @babel\n                // │     ├─ code-frame\n                // │     └─ compat-data (next)\n                // ├─ src (current)\n                item = item.lastElementChild.lastElementChild;\n            } else {\n                break;\n            }\n        }\n\n        return [item, getNodeAt(nodes, item.dataset.index)];\n    } else {\n        // ├─ node_modules\n        // │  └─ @babel (next)\n        // │     ├─ code-frame (current)\n        // │     └─ compat-data\n        return moveToParent(current, nodes);\n    }\n};\n\nexport const moveDown = (current, nodes) => {\n    let item = current;\n    const { isExpanded } = getExpandState(current);\n\n    if (isExpanded) {\n        // ├─ node_modules (current)\n        // │  └─ @babel (next)\n        // │     ├─ code-frame\n        // │     └─ compat-data\n        // ├─ src\n        item = current.lastElementChild.firstElementChild;\n    } else {\n        // go to parent and find its next sibling until we find a node or reach the end of the tree\n        // ├─ node_modules\n        // │  └─ @babel\n        // │     ├─ code-frame\n        // │     └─ compat-data (current)\n        // ├─ src (next)\n        while (true) {\n            // ├─ node_modules\n            // │  └─ @babel\n            // │     ├─ code-frame\n            // │     └─ compat-data (current)\n            if (isLastItem(item, nodes)) {\n                // we are at the end of the tree\n                return [null, null];\n            }\n\n            if (item.nextElementSibling) {\n                item = item.nextElementSibling;\n                break;\n            }\n\n            item = item.parentElement.parentElement;\n        }\n    }\n\n    return [item, getNodeAt(nodes, item.dataset.index)];\n};\n\nexport const moveLeft = (current, nodes) => {\n    const { isExpandable, isExpanded } = getExpandState(current);\n    const index = current.dataset.index;\n\n    if (isExpandable && isExpanded) {\n        // ├─ src (current)\n        // │ ├─ App.jsx\n        // │ └─ data.js       -> ├─ src (next)\n        // ├─ .editorconfig      ├─ .editorconfig\n        // └─ .gitignore.js      └─ .gitignore.js\n        return [null, getNodeAt(nodes, index)];\n    } else {\n        // ├─ src (next)\n        // │ ├─ App.jsx\n        // │ └─ data.js (current)\n        // ├─ .editorconfig\n        // └─ .gitignore.js\n        return moveToParent(current, nodes);\n    }\n};\n\nexport const moveRight = (current, nodes) => {\n    const { isExpandable, isExpanded } = getExpandState(current);\n\n    if (isExpandable) {\n        const index = current.dataset.index;\n        const node = getNodeAt(nodes, index);\n\n        if (isExpanded) {\n            // ├─ src (current)\n            // │ ├─ App.jsx (next)\n            // │ └─ data.js\n            // ├─ .editorconfig\n            // └─ .gitignore.js\n            const item = current.lastElementChild.firstElementChild;\n            const next = node.nodes[0];\n\n            return [item, next];\n        } else {\n            // ├─ src (current)      ├─ src (next)\n            // ├─ .editorconfig      │ ├─ App.jsx\n            // └─ .gitignore.js   -> │ └─ data.js\n            //                       ├─ .editorconfig\n            //                       └─ .gitignore.js\n            return [null, node];\n        }\n    }\n\n    // ├─ src\n    // │ ├─ App.jsx\n    // │ └─ data.js\n    // ├─ .editorconfig (current)\n    // └─ .gitignore.js\n    return [null, null];\n};\n\nconst moveToParent = (current, nodes) => {\n    const path = current.dataset.index.split('-');\n\n    if (path.length > 1) {\n        const item = current.parentElement.parentElement;\n\n        return [item, getNodeAt(nodes, item.dataset.index)];\n    }\n\n    return [null, null];\n};\n\nexport const getExpandState = (node) => {\n    const ariaExpandedAttribute = node.getAttribute('aria-expanded');\n\n    return {\n        isExpandable: ariaExpandedAttribute !== null,\n        isExpanded: ariaExpandedAttribute === 'true',\n    };\n};\n\nconst isLastItem = (item, nodes) => {\n    const path = item.dataset.index.split('-');\n\n    return path.length === 1 && parseInt(path[0], 10) === nodes.length - 1;\n};\n\nexport const shallowEquals = (prev, next, ignored) => {\n    if (Object.is(prev, next)) {\n        return true;\n    }\n\n    const keysPrev = Object.keys(prev).filter((key) => !ignored.includes(key));\n    const keysNext = Object.keys(next).filter((key) => !ignored.includes(key));\n\n    if (keysPrev.length !== keysNext.length) {\n        return false;\n    }\n\n    for (const key of keysPrev) {\n        if (!Object.prototype.hasOwnProperty.call(next, key) || !Object.is(prev[key], next[key])) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nexport const internalId = Symbol('id');\n\nexport const addInternalIds = (nodes, parentId) => {\n    let result = [];\n    let i = nodes.length - 1;\n\n    while (i >= 0) {\n        result.push({\n            ...nodes[i],\n            [internalId]: parentId ? `${parentId}-${i}` : `${i}`,\n        });\n\n        i--;\n    }\n\n    return result;\n};\n\nexport const flattenData = (nodes, expanded) => {\n    const stack = addInternalIds(nodes, '');\n    const tree = [];\n\n    while (stack.length) {\n        const node = stack.pop();\n\n        tree.push(node);\n\n        if (expanded.includes(node.id)) {\n            stack.push(...addInternalIds(node.nodes, node[internalId]));\n        }\n    }\n\n    return tree;\n};\n","import { useRef, useEffect, memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst TreeItem = ({\n    node,\n    index,\n    selected,\n    focused,\n    expanded,\n    setSize,\n    counter,\n    onItemSelect,\n    renderLabel,\n    onKeyDown,\n}) => {\n    const isExpandable = node.nodes.length > 0;\n    const isExpanded = isExpandable ? expanded.includes(node.id) : null;\n\n    const path = index.split('-');\n    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n\n    const el = useRef();\n\n    useEffect(() => {\n        if (counter > 0 && focused === node.id) {\n            if (el.current) {\n                el.current.focus();\n                el.current.firstElementChild.scrollIntoView({ block: 'nearest' });\n            }\n        }\n    }, [counter]);\n\n    return (\n        <li\n            ref={el}\n            role=\"treeitem\"\n            tabIndex={focused === node.id ? 0 : -1}\n            aria-expanded={isExpanded}\n            aria-selected={selected === node.id || null}\n            aria-level={path.length}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(node, { isExpandable, isExpanded })\n            ) : (\n                <div onClick={() => onItemSelect(node)}>{node.label}</div>\n            )}\n\n            {isExpanded && isExpandable && (\n                <ul role=\"group\">\n                    {node.nodes.map((node, childIndex) => (\n                        <MemoTreeItem\n                            key={node.id}\n                            node={node}\n                            index={index + '-' + childIndex}\n                            selected={selected}\n                            focused={focused}\n                            expanded={expanded}\n                            setSize={node.nodes.length}\n                            counter={counter}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    ))}\n                </ul>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    TreeItem.displayName = 'TreeItem';\n}\n\nconst propsAreEqual = (prev, next) => {\n    // ignore object identity of these props\n    const ignored = ['counter', 'selected', 'focused', 'expanded', 'onItemSelect', 'onKeyDown'];\n    const areOtherPropsDifferent = !shallowEquals(prev, next, ignored);\n\n    if (areOtherPropsDifferent) {\n        // other props are different - trigger a rerender\n        return false;\n    }\n\n    // breadth first traverse - when working with file system like trees the user usually starts from the outer nodes\n    // and most of the tree changes will be happening near the root of the tree\n    const stack = [{ ...next.node, nodes: [] }, ...next.node.nodes];\n\n    while (stack.length) {\n        const node = stack.shift();\n\n        if (node.id === next.focused || node.id === prev.focused) {\n            // a node or one of its children has to change its `tabIndex` - trigger a rerender\n            return false;\n        }\n\n        if (node.id === next.selected || node.id === prev.selected) {\n            // a node or one of its children has to change its `aria-selected` - trigger a rerender\n            return false;\n        }\n\n        if (prev.expanded.includes(node.id) !== next.expanded.includes(node.id)) {\n            // a node or one of its children has to be collapsed/expanded - trigger a rerender\n            return false;\n        }\n\n        stack.push(...node.nodes);\n    }\n\n    return true;\n};\n\nconst MemoTreeItem = memo(TreeItem, propsAreEqual);\n\nexport default MemoTreeItem;\n","import { useState, useCallback } from 'react';\n\nimport { isUndefined, isFn } from './utils';\n\nconst useInternalState = (valueProp, defaultValue) => {\n    const [valueState, setValueState] = useState(defaultValue);\n    const isUncontrolled = isUndefined(valueProp);\n    const value = isUncontrolled ? valueState : valueProp;\n\n    const updateValue = useCallback(\n        (next) => {\n            if (isUncontrolled) {\n                setValueState(next);\n            }\n        },\n        [isUncontrolled, value]\n    );\n\n    return [value, updateValue];\n};\n\nexport default useInternalState;\n","import { useState, forwardRef, useImperativeHandle, memo } from 'react';\n\nimport TreeItem from './TreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport basePropTypes from '../basePropTypes.js';\n\nimport { moveUp, moveDown, moveLeft, moveRight, getNodeAt, noop, isUndefined } from '../utils.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst TreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    const [counter, setCounter] = useState(0);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setCounter((prev) => prev + 1);\n            },\n        };\n    });\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            const [item, node] = moveUp(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            const [item, node] = moveDown(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const [item, node] = moveLeft(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n\n            if (!item && node) {\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const [item, node] = moveRight(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n\n            if (!item && node) {\n                setExpanded((prev) => prev.concat(node.id));\n                onExpandChange(node);\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    // @todo since the el.focus() call was moved to the TreeItem we no longer need the el\n    const focusTreeItem = (el, node) => {\n        setCounter((prev) => prev + 1);\n\n        setFocused(node.id);\n        onFocusChange(node);\n\n        if (selectionFollowsFocus) {\n            setSelected(node.id);\n            onSelectChange(node);\n        }\n    };\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    return (\n        <ul role=\"tree\" {...rest}>\n            {nodes.map((node, index) => (\n                <TreeItem\n                    key={node.id}\n                    node={node}\n                    index={`${index}`}\n                    selected={selected}\n                    focused={focused}\n                    expanded={expanded}\n                    setSize={nodes.length}\n                    counter={counter}\n                    renderLabel={renderLabel}\n                    onItemSelect={onItemSelect}\n                    onKeyDown={onKeyDown}\n                />\n            ))}\n        </ul>\n    );\n};\n\nconst Tree = forwardRef(TreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    Tree.displayName = 'Tree';\n    Tree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(Tree);\n","import { memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst VirtualTreeItem = ({\n    node,\n\n    measureRef,\n    start,\n\n    isExpanded,\n    isSelected,\n\n    tabIndex,\n    level,\n    positionInSet,\n    setSize,\n\n    index,\n    counter,\n    isFocused,\n\n    renderLabel,\n    onItemSelect,\n    onKeyDown,\n}) => {\n    return (\n        <li\n            ref={measureRef}\n            role=\"treeitem\"\n            tabIndex={tabIndex}\n            aria-expanded={isExpanded}\n            aria-selected={isSelected || null}\n            aria-level={level}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            style={{\n                position: 'absolute',\n                top: 0,\n                transform: `translateY(${start}px)`,\n                '--level': level,\n            }}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(node, { isExpanded, isExpandable: node.nodes.length > 0 })\n            ) : (\n                <div onClick={() => onItemSelect(node)}>{node.label}</div>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTreeItem.displayName = 'VirtualTreeItem';\n}\n\nconst MemoVirtualTreeItem = memo(VirtualTreeItem, (prev, next) =>\n    // ignore object identity of these props\n    shallowEquals(prev, next, ['measureRef', 'onItemSelect', 'onKeyDown'])\n);\n\nexport default MemoVirtualTreeItem;\n","import { forwardRef, useImperativeHandle, useState, useEffect, memo, useRef, useCallback, useMemo } from 'react';\nimport { useVirtual, defaultRangeExtractor } from 'react-virtual';\nimport PropTypes from 'prop-types';\n\nimport VirtualTreeItem from './VirtualTreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport { internalId, flattenData, getExpandState, getNodeAt, noop, isUndefined, isFn } from '../utils.js';\nimport basePropTypes from '../basePropTypes.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst VirtualTreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        rowHeight = 30,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    const parentRef = useRef();\n    const flattened = useMemo(() => flattenData(nodes, expanded), [nodes, expanded]);\n\n    const rowVirtualizer = useVirtual({\n        estimateSize: useCallback(() => rowHeight, [rowHeight]),\n\n        size: flattened.length,\n        parentRef,\n\n        // prerender the focused item, the one before it, after it, the parent item of the focused one\n        rangeExtractor(range) {\n            const defaultRange = defaultRangeExtractor(range);\n            const focusedIndex = flattened.findIndex((node) => node.id === focused);\n\n            if (focusedIndex === -1) {\n                return defaultRange;\n            } else {\n                let range = new Set(defaultRange);\n\n                const node = flattened[focusedIndex];\n                const path = node[internalId].split('-');\n                const parent = path.length > 1 ? getNodeAt(nodes, path.slice(0, -1).join('-')) : null;\n\n                if (parent) {\n                    range.add(flattened.findIndex((node) => node.id === parent.id));\n                }\n\n                if (focusedIndex > 0) {\n                    range.add(focusedIndex - 1);\n                }\n\n                range.add(focusedIndex);\n\n                if (focusedIndex < flattened.length - 1) {\n                    range.add(focusedIndex + 1);\n                }\n\n                return [...range];\n            }\n        },\n    });\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    // this is mostly done to allow users of the component to call `.focus()` from the imperative handle\n    const [counter, setCounter] = useState(0);\n\n    useEffect(() => {\n        if (counter > 0) {\n            const index = flattened.findIndex((node) => node.id === focused);\n            const node = flattened[index];\n            const el = parentRef.current.querySelector(`[data-index=\"${node[internalId]}\"]`);\n\n            rowVirtualizer.scrollToIndex(index);\n\n            if (el) {\n                el.focus();\n            }\n        }\n    }, [counter]);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setCounter((prev) => prev + 1);\n            },\n        };\n    });\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            if (flattened[0].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index - 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            if (flattened[flattened.length - 1].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index + 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable && isExpanded) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const node = flattened[index];\n\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n\n                focusTreeItem(node);\n            } else {\n                const path = e.currentTarget.dataset.index.split('-');\n\n                if (path.length > 1) {\n                    const parentNode = getNodeAt(nodes, path.slice(0, -1).join('-'));\n                    const index = flattened.findIndex((node) => node.id === parentNode.id);\n                    const node = flattened[index]; // we do this, because parentNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable) {\n                if (isExpanded) {\n                    const childNode = getNodeAt(nodes, e.currentTarget.dataset.index).nodes[0];\n\n                    const index = flattened.findIndex((node) => node.id === childNode.id);\n                    const node = flattened[index]; // we do this, because childNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                } else {\n                    const index = flattened.findIndex((node) => node.id === focused);\n                    const node = flattened[index];\n\n                    setExpanded((prev) => prev.concat(node.id));\n                    onExpandChange(node);\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    const focusTreeItem = (node) => {\n        if (node.id !== focused) {\n            setCounter((prev) => prev + 1);\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        if (selectionFollowsFocus) {\n            setSelected(node.id);\n            onSelectChange(node);\n        }\n    };\n\n    const treeStyles = useMemo(() => {\n        return {\n            height: rowVirtualizer.totalSize + 'px',\n            position: 'relative',\n            margin: 0,\n            padding: 0,\n        };\n    }, [rowVirtualizer.totalSize]);\n\n    return (\n        <div {...rest} ref={parentRef}>\n            <ul role=\"tree\" style={treeStyles}>\n                {rowVirtualizer.virtualItems.map((virtualRow) => {\n                    const node = flattened[virtualRow.index];\n\n                    const path = node[internalId].split('-');\n\n                    const level = path.length;\n                    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n                    const setSize =\n                        path.length === 1 ? nodes.length : getNodeAt(nodes, path.slice(0, -1).join('-')).nodes.length;\n\n                    const isExpandable = node.nodes.length > 0;\n                    const isExpanded = isExpandable ? expanded.includes(node.id) : null;\n\n                    return (\n                        <VirtualTreeItem\n                            key={virtualRow.index}\n                            node={node}\n                            measureRef={virtualRow.measureRef}\n                            start={virtualRow.start}\n                            isExpanded={isExpanded}\n                            isSelected={selected === node.id}\n                            tabIndex={focused === node.id ? 0 : -1}\n                            level={level}\n                            positionInSet={positionInSet}\n                            setSize={setSize}\n                            index={node[internalId]}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    );\n                })}\n            </ul>\n        </div>\n    );\n};\n\nconst VirtualTree = forwardRef(VirtualTreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTree.displayName = 'VirtualTree';\n    VirtualTree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(VirtualTree);\n"],"names":["noop","isFn","value","isUndefined","getNodeAt","nodes","index","path","split","node","i","length","undefined","moveToParent","current","dataset","item","parentElement","getExpandState","ariaExpandedAttribute","getAttribute","isExpandable","isExpanded","isLastItem","parseInt","shallowEquals","prev","next","ignored","Object","is","keysPrev","keys","filter","key","includes","keysNext","prototype","hasOwnProperty","call","internalId","Symbol","addInternalIds","parentId","result","push","TreeItem","_ref","selected","focused","expanded","setSize","counter","onItemSelect","renderLabel","onKeyDown","id","positionInSet","el","useRef","useEffect","focus","firstElementChild","scrollIntoView","block","React","ref","role","tabIndex","onClick","label","map","childIndex","MemoTreeItem","propsAreEqual","stack","shift","memo","valueProp","defaultValue","valueState","setValueState","useState","isUncontrolled","useCallback","TreeImpl","defaultFocused","focusedProp","onFocusChange","defaultExpanded","expandedProp","onExpandChange","selectionTogglesExpanded","selectionFollowsFocus","defaultSelected","selectedProp","onSelectChange","rest","initialFocus","setFocused","useInternalState","setExpanded","setSelected","setCounter","useImperativeHandle","e","altKey","ctrlKey","metaKey","target","currentTarget","preventDefault","previousElementSibling","lastElementChild","moveUp","focusTreeItem","nextElementSibling","moveDown","moveLeft","moveRight","concat","Tree","forwardRef","VirtualTreeItem","measureRef","start","isSelected","level","isFocused","style","position","top","transform","VirtualTreeImpl","rowHeight","parentRef","flattened","useMemo","tree","pop","flattenData","rowVirtualizer","useVirtual","estimateSize","size","rangeExtractor","range","defaultRange","defaultRangeExtractor","focusedIndex","findIndex","Set","parent","slice","join","add","querySelector","scrollToIndex","stopPropagation","parentNode","childNode","treeStyles","height","totalSize","margin","padding","virtualItems","virtualRow","VirtualTree"],"mappings":"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"}