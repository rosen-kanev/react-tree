{"version":3,"file":"react-tree.umd.min.js","sources":["../src/utils.js","../src/regular/TreeItem.jsx","../src/useInternalState.js","../src/regular/Tree.jsx","../src/virtual/VirtualTreeItem.jsx","../src/virtual/VirtualTree.jsx"],"sourcesContent":["export const noop = () => {};\n\nexport const isFn = (value) => typeof value === 'function';\nexport const isUndefined = (value) => typeof value === 'undefined';\n\nexport const getNodeAt = (nodes, index) => {\n    const path = index.split('-');\n    let node = { nodes };\n    let i = 0;\n\n    while (node != null && i < path.length) {\n        node = node.nodes[path[i++]];\n    }\n\n    return i && i === path.length ? node : undefined;\n};\n\nexport const moveUp = (current, nodes) => {\n    if (current.dataset.index === '0') {\n        // we are at the start of the tree\n        return [null, null];\n    }\n\n    if (current.previousElementSibling) {\n        // move back a node and find the deepest leaf node\n        let item = current.previousElementSibling;\n\n        while (true) {\n            const { isExpanded, isExpandable } = getExpandState(item);\n\n            if (isExpandable && isExpanded) {\n                // ├─ node_modules\n                // │  └─ @babel\n                // │     ├─ code-frame\n                // │     └─ compat-data (next)\n                // ├─ src (current)\n                item = item.lastElementChild.lastElementChild;\n            } else {\n                break;\n            }\n        }\n\n        return [item, getNodeAt(nodes, item.dataset.index)];\n    } else {\n        // ├─ node_modules\n        // │  └─ @babel (next)\n        // │     ├─ code-frame (current)\n        // │     └─ compat-data\n        return moveToParent(current, nodes);\n    }\n};\n\nexport const moveDown = (current, nodes) => {\n    let item = current;\n    const { isExpanded } = getExpandState(current);\n\n    if (isExpanded) {\n        // ├─ node_modules (current)\n        // │  └─ @babel (next)\n        // │     ├─ code-frame\n        // │     └─ compat-data\n        // ├─ src\n        item = current.lastElementChild.firstElementChild;\n    } else {\n        // go to parent and find its next sibling until we find a node or reach the end of the tree\n        // ├─ node_modules\n        // │  └─ @babel\n        // │     ├─ code-frame\n        // │     └─ compat-data (current)\n        // ├─ src (next)\n        while (true) {\n            // ├─ node_modules\n            // │  └─ @babel\n            // │     ├─ code-frame\n            // │     └─ compat-data (current)\n            if (isLastItem(item, nodes)) {\n                // we are at the end of the tree\n                return [null, null];\n            }\n\n            if (item.nextElementSibling) {\n                item = item.nextElementSibling;\n                break;\n            }\n\n            item = item.parentElement.parentElement;\n        }\n    }\n\n    return [item, getNodeAt(nodes, item.dataset.index)];\n};\n\nexport const moveLeft = (current, nodes) => {\n    const { isExpandable, isExpanded } = getExpandState(current);\n    const index = current.dataset.index;\n\n    if (isExpandable && isExpanded) {\n        // ├─ src (current)\n        // │ ├─ App.jsx\n        // │ └─ data.js       -> ├─ src (next)\n        // ├─ .editorconfig      ├─ .editorconfig\n        // └─ .gitignore.js      └─ .gitignore.js\n        return [null, getNodeAt(nodes, index)];\n    } else {\n        // ├─ src (next)\n        // │ ├─ App.jsx\n        // │ └─ data.js (current)\n        // ├─ .editorconfig\n        // └─ .gitignore.js\n        return moveToParent(current, nodes);\n    }\n};\n\nexport const moveRight = (current, nodes) => {\n    const { isExpandable, isExpanded } = getExpandState(current);\n\n    if (isExpandable) {\n        const index = current.dataset.index;\n        const node = getNodeAt(nodes, index);\n\n        if (isExpanded) {\n            // ├─ src (current)\n            // │ ├─ App.jsx (next)\n            // │ └─ data.js\n            // ├─ .editorconfig\n            // └─ .gitignore.js\n            const item = current.lastElementChild.firstElementChild;\n            const next = node.nodes[0];\n\n            return [item, next];\n        } else {\n            // ├─ src (current)      ├─ src (next)\n            // ├─ .editorconfig      │ ├─ App.jsx\n            // └─ .gitignore.js   -> │ └─ data.js\n            //                       ├─ .editorconfig\n            //                       └─ .gitignore.js\n            return [null, node];\n        }\n    }\n\n    // ├─ src\n    // │ ├─ App.jsx\n    // │ └─ data.js\n    // ├─ .editorconfig (current)\n    // └─ .gitignore.js\n    return [null, null];\n};\n\nconst moveToParent = (current, nodes) => {\n    const path = current.dataset.index.split('-');\n\n    if (path.length > 1) {\n        const item = current.parentElement.parentElement;\n\n        return [item, getNodeAt(nodes, item.dataset.index)];\n    }\n\n    return [null, null];\n};\n\nexport const getExpandState = (node) => {\n    const ariaExpandedAttribute = node.getAttribute('aria-expanded');\n\n    return {\n        isExpandable: ariaExpandedAttribute !== null,\n        isExpanded: ariaExpandedAttribute === 'true',\n    };\n};\n\nconst isLastItem = (item, nodes) => {\n    const path = item.dataset.index.split('-');\n\n    return path.length === 1 && parseInt(path[0], 10) === nodes.length - 1;\n};\n\nexport const shallowEquals = (prev, next, ignored) => {\n    if (Object.is(prev, next)) {\n        return true;\n    }\n\n    const keysPrev = Object.keys(prev).filter((key) => !ignored.includes(key));\n    const keysNext = Object.keys(next).filter((key) => !ignored.includes(key));\n\n    if (keysPrev.length !== keysNext.length) {\n        return false;\n    }\n\n    for (const key of keysPrev) {\n        if (!Object.prototype.hasOwnProperty.call(next, key) || !Object.is(prev[key], next[key])) {\n            // console.log(key, 'changed', prev[key], next[key]);\n            return false;\n        }\n    }\n\n    return true;\n};\n\nexport const internalId = Symbol('id');\n\nexport const addInternalIds = (nodes, parentId) => {\n    let result = [];\n    let i = nodes.length - 1;\n\n    while (i >= 0) {\n        result.push({\n            ...nodes[i],\n            [internalId]: parentId ? `${parentId}-${i}` : `${i}`,\n        });\n\n        i--;\n    }\n\n    return result;\n};\n\nexport const flattenData = (nodes, expanded) => {\n    const stack = addInternalIds(nodes, '');\n    const tree = [];\n\n    while (stack.length) {\n        const node = stack.pop();\n\n        tree.push(node);\n\n        if (expanded.includes(node.id)) {\n            stack.push(...addInternalIds(node.nodes, node[internalId]));\n        }\n    }\n\n    return tree;\n};\n","import { useRef, useEffect, memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst TreeItem = ({\n    onItemSelect,\n    renderLabel,\n    focused,\n    selected,\n    expanded,\n    index,\n    setSize,\n    counter,\n    onKeyDown,\n    ...props\n}) => {\n    const isExpandable = props.nodes.length > 0;\n    const isExpanded = isExpandable ? expanded.includes(props.id) : null;\n\n    const path = index.split('-');\n    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n\n    const el = useRef();\n\n    useEffect(() => {\n        if (counter > 0 && focused === props.id) {\n            if (el.current) {\n                el.current.focus();\n                el.current.firstElementChild.scrollIntoView({ block: 'nearest' });\n            }\n        }\n    }, [counter]);\n\n    return (\n        <li\n            ref={el}\n            role=\"treeitem\"\n            tabIndex={focused === props.id ? 0 : -1}\n            aria-expanded={isExpanded}\n            aria-selected={selected === props.id || null}\n            aria-level={path.length}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(props, { isExpandable, isExpanded })\n            ) : (\n                <div onClick={() => onItemSelect(props)}>{props.label}</div>\n            )}\n\n            {isExpanded && isExpandable && (\n                <ul role=\"group\">\n                    {props.nodes.map((node, childIndex) => (\n                        <MemoTreeItem\n                            {...node}\n                            key={node.id}\n                            index={index + '-' + childIndex}\n                            selected={selected}\n                            focused={focused}\n                            expanded={expanded}\n                            setSize={props.nodes.length}\n                            counter={counter}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    ))}\n                </ul>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    TreeItem.displayName = 'TreeItem';\n}\n\nconst propsAreEqual = (prev, next) => {\n    // ignore object identity of these props\n    const ignored = ['counter', 'selected', 'focused', 'expanded', 'onItemSelect', 'onKeyDown'];\n    const areOtherPropsDifferent = !shallowEquals(prev, next, ignored);\n\n    if (areOtherPropsDifferent) {\n        // other props are different - trigger a rerender\n        return false;\n    }\n\n    // breadth first traverse - when working with file system like trees the user usually starts from the outer nodes\n    // and most of the tree changes will be happening near the root of the tree\n    const stack = [{ ...next, nodes: [] }, ...next.nodes];\n\n    while (stack.length) {\n        const node = stack.shift();\n\n        if (node.id === next.focused || node.id === prev.focused) {\n            // a node or one of its children has to change its `tabIndex` - trigger a rerender\n            return false;\n        }\n\n        if (node.id === next.selected || node.id === prev.selected) {\n            // a node or one of its children has to change its `aria-selected` - trigger a rerender\n            return false;\n        }\n\n        if (prev.expanded.includes(node.id) !== next.expanded.includes(node.id)) {\n            // a node or one of its children has to be collapsed/expanded - trigger a rerender\n            return false;\n        }\n\n        stack.push(...node.nodes);\n    }\n\n    return true;\n};\n\nconst MemoTreeItem = memo(TreeItem, propsAreEqual);\n\nexport default MemoTreeItem;\n","import { useState, useCallback } from 'react';\n\nimport { isUndefined, isFn } from './utils';\n\nconst useInternalState = (valueProp, defaultValue) => {\n    const [valueState, setValueState] = useState(defaultValue);\n    const isUncontrolled = isUndefined(valueProp);\n    const value = isUncontrolled ? valueState : valueProp;\n\n    const updateValue = useCallback(\n        (next) => {\n            if (isUncontrolled) {\n                setValueState(next);\n            }\n        },\n        [isUncontrolled, value]\n    );\n\n    return [value, updateValue];\n};\n\nexport default useInternalState;\n","import { useState, forwardRef, useImperativeHandle, memo } from 'react';\n\nimport TreeItem from './TreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport basePropTypes from '../basePropTypes.js';\n\nimport { moveUp, moveDown, moveLeft, moveRight, getNodeAt, noop, isUndefined } from '../utils.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst TreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    const [counter, setCounter] = useState(0);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setCounter((prev) => prev + 1);\n            },\n        };\n    });\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            const [item, node] = moveUp(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            const [item, node] = moveDown(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const [item, node] = moveLeft(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n\n            if (!item && node) {\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const [item, node] = moveRight(e.currentTarget, nodes);\n\n            if (item) {\n                focusTreeItem(item, node);\n            }\n\n            if (!item && node) {\n                setExpanded((prev) => prev.concat(node.id));\n                onExpandChange(node);\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    // @todo since the el.focus() call was moved to the TreeItem we no longer need the el\n    const focusTreeItem = (el, node) => {\n        setCounter((prev) => prev + 1);\n\n        setFocused(node.id);\n        onFocusChange(node);\n\n        if (selectionFollowsFocus) {\n            setSelected(node.id);\n            onSelectChange(node);\n        }\n    };\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    // @todo should we pass node={node}?\n    // currently index, selected, focused, etc... are preventing users from\n    // using the same properties in a node\n    return (\n        <ul role=\"tree\" {...rest}>\n            {nodes.map((node, index) => (\n                <TreeItem\n                    {...node}\n                    key={node.id}\n                    index={`${index}`}\n                    selected={selected}\n                    focused={focused}\n                    expanded={expanded}\n                    setSize={nodes.length}\n                    counter={counter}\n                    renderLabel={renderLabel}\n                    onItemSelect={onItemSelect}\n                    onKeyDown={onKeyDown}\n                />\n            ))}\n        </ul>\n    );\n};\n\nconst Tree = forwardRef(TreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    Tree.displayName = 'Tree';\n    Tree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(Tree);\n","import { memo } from 'react';\n\nimport { isFn, shallowEquals } from '../utils';\n\nconst VirtualTreeItem = ({\n    measureRef,\n    start,\n\n    isExpanded,\n    isSelected,\n\n    tabIndex,\n    level,\n    positionInSet,\n    setSize,\n\n    index,\n    counter,\n    isFocused,\n\n    renderLabel,\n    onItemSelect,\n    onKeyDown,\n\n    ...props\n}) => {\n    return (\n        <li\n            ref={measureRef}\n            role=\"treeitem\"\n            tabIndex={tabIndex}\n            aria-expanded={isExpanded}\n            aria-selected={isSelected || null}\n            aria-level={level}\n            aria-posinset={positionInSet}\n            aria-setsize={setSize}\n            data-index={index}\n            style={{\n                position: 'absolute',\n                top: 0,\n                transform: `translateY(${start}px)`,\n                '--level': level,\n            }}\n            onKeyDown={onKeyDown}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel(props, { isExpanded, isExpandable: props.nodes.length > 0 })\n            ) : (\n                <div onClick={() => onItemSelect(props)}>{props.label}</div>\n            )}\n        </li>\n    );\n};\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTreeItem.displayName = 'VirtualTreeItem';\n}\n\nconst MemoVirtualTreeItem = memo(VirtualTreeItem, (prev, next) =>\n    // ignore object identity of these props\n    shallowEquals(prev, next, ['measureRef', 'onItemSelect', 'onKeyDown'])\n);\n\nexport default MemoVirtualTreeItem;\n","import { forwardRef, useImperativeHandle, useState, useEffect, memo, useRef, useCallback, useMemo } from 'react';\nimport { useVirtual, defaultRangeExtractor } from 'react-virtual';\nimport PropTypes from 'prop-types';\n\nimport VirtualTreeItem from './VirtualTreeItem.jsx';\n\nimport useInternalState from '../useInternalState.js';\nimport { internalId, flattenData, getExpandState, getNodeAt, noop, isUndefined, isFn } from '../utils.js';\nimport basePropTypes from '../basePropTypes.js';\n\n/**\n * An accessible tree view component, based on the WAI-ARIA authoring practices for accessible widgets.\n *\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#TreeView\n */\nconst VirtualTreeImpl = (\n    {\n        nodes,\n\n        defaultFocused,\n        focused: focusedProp,\n        onFocusChange = noop,\n\n        defaultExpanded = [],\n        expanded: expandedProp,\n        onExpandChange = noop,\n\n        selectionTogglesExpanded = true,\n        selectionFollowsFocus,\n        defaultSelected,\n        selected: selectedProp,\n        onSelectChange = noop,\n\n        renderLabel,\n        rowHeight = 30,\n        ...rest\n    },\n    ref\n) => {\n    const initialFocus = isUndefined(focusedProp)\n        ? isUndefined(defaultFocused) && nodes.length > 0\n            ? nodes[0].id\n            : defaultFocused\n        : undefined;\n\n    const [focused, setFocused] = useInternalState(focusedProp, initialFocus);\n    const [expanded, setExpanded] = useInternalState(expandedProp, defaultExpanded);\n    const [selected, setSelected] = useInternalState(selectedProp, defaultSelected);\n\n    const parentRef = useRef();\n    const flattened = useMemo(() => flattenData(nodes, expanded), [nodes, expanded]);\n\n    const rowVirtualizer = useVirtual({\n        estimateSize: useCallback(() => rowHeight, [rowHeight]),\n\n        size: flattened.length,\n        parentRef,\n\n        // prerender the focused item, the one before it, after it, the parent item of the focused one\n        rangeExtractor(range) {\n            const defaultRange = defaultRangeExtractor(range);\n            const focusedIndex = flattened.findIndex((node) => node.id === focused);\n\n            if (focusedIndex === -1) {\n                return defaultRange;\n            } else {\n                let range = new Set(defaultRange);\n\n                const node = flattened[focusedIndex];\n                const path = node[internalId].split('-');\n                const parent = path.length > 1 ? getNodeAt(nodes, path.slice(0, -1).join('-')) : null;\n\n                if (parent) {\n                    range.add(flattened.findIndex((node) => node.id === parent.id));\n                }\n\n                if (focusedIndex > 0) {\n                    range.add(focusedIndex - 1);\n                }\n\n                range.add(focusedIndex);\n\n                if (focusedIndex < flattened.length - 1) {\n                    range.add(focusedIndex + 1);\n                }\n\n                return [...range];\n            }\n        },\n    });\n\n    // hacky way to signal the currently `focused` TreeItem to call el.focus()\n    // this is mostly done to allow users of the component to call `.focus()` from the imperative handle\n    const [counter, setCounter] = useState(0);\n\n    useEffect(() => {\n        if (counter > 0) {\n            const index = flattened.findIndex((node) => node.id === focused);\n            const node = flattened[index];\n            const el = parentRef.current.querySelector(`[data-index=\"${node[internalId]}\"]`);\n\n            rowVirtualizer.scrollToIndex(index);\n\n            if (el) {\n                el.focus();\n            }\n        }\n    }, [counter]);\n\n    useImperativeHandle(ref, () => {\n        return {\n            focus() {\n                setCounter((prev) => prev + 1);\n            },\n        };\n    });\n\n    const onItemSelect = (node) => {\n        if (selectionTogglesExpanded && node.nodes.length > 0) {\n            setExpanded((prev) => {\n                return prev.includes(node.id) ? prev.filter((id) => id !== node.id) : prev.concat(node.id);\n            });\n            onExpandChange(node);\n        }\n\n        if (node.id !== focused) {\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        setSelected(node.id);\n        onSelectChange(node);\n    };\n\n    const onKeyDown = (e) => {\n        /* istanbul ignore next we test this, but the code coverage tool is still unconvinced */\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey || e.target !== e.currentTarget) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            if (flattened[0].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index - 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            if (flattened[flattened.length - 1].id !== focused) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const nextIndex = index + 1;\n                const node = flattened[nextIndex];\n\n                focusTreeItem(node);\n            }\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable && isExpanded) {\n                const index = flattened.findIndex((node) => node.id === focused);\n                const node = flattened[index];\n\n                setExpanded((prev) => prev.filter((id) => id !== node.id));\n                onExpandChange(node);\n\n                focusTreeItem(node);\n            } else {\n                const path = e.currentTarget.dataset.index.split('-');\n\n                if (path.length > 1) {\n                    const parentNode = getNodeAt(nodes, path.slice(0, -1).join('-'));\n                    const index = flattened.findIndex((node) => node.id === parentNode.id);\n                    const node = flattened[index]; // we do this, because parentNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const { isExpandable, isExpanded } = getExpandState(e.currentTarget);\n\n            if (isExpandable) {\n                if (isExpanded) {\n                    const childNode = getNodeAt(nodes, e.currentTarget.dataset.index).nodes[0];\n\n                    const index = flattened.findIndex((node) => node.id === childNode.id);\n                    const node = flattened[index]; // we do this, because childNode doesn't have node[internalId]\n\n                    focusTreeItem(node);\n                } else {\n                    const index = flattened.findIndex((node) => node.id === focused);\n                    const node = flattened[index];\n\n                    setExpanded((prev) => prev.concat(node.id));\n                    onExpandChange(node);\n\n                    focusTreeItem(node);\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const node = getNodeAt(nodes, e.currentTarget.dataset.index);\n\n            onItemSelect(node);\n        }\n    };\n\n    const focusTreeItem = (node) => {\n        if (node.id !== focused) {\n            setCounter((prev) => prev + 1);\n            setFocused(node.id);\n            onFocusChange(node);\n        }\n\n        if (selectionFollowsFocus) {\n            setSelected(node.id);\n            onSelectChange(node);\n        }\n    };\n\n    const treeStyles = useMemo(() => {\n        return {\n            height: rowVirtualizer.totalSize + 'px',\n            position: 'relative',\n            margin: 0,\n            padding: 0,\n        };\n    }, [rowVirtualizer.totalSize]);\n\n    return (\n        <div {...rest} ref={parentRef}>\n            <ul role=\"tree\" style={treeStyles}>\n                {rowVirtualizer.virtualItems.map((virtualRow) => {\n                    const node = flattened[virtualRow.index];\n\n                    const path = node[internalId].split('-');\n\n                    const level = path.length;\n                    const positionInSet = parseInt(path[path.length - 1], 10) + 1;\n                    const setSize =\n                        path.length === 1 ? nodes.length : getNodeAt(nodes, path.slice(0, -1).join('-')).nodes.length;\n\n                    const isExpandable = node.nodes.length > 0;\n                    const isExpanded = isExpandable ? expanded.includes(node.id) : null;\n\n                    return (\n                        <VirtualTreeItem\n                            {...node}\n                            key={virtualRow.index}\n                            measureRef={virtualRow.measureRef}\n                            start={virtualRow.start}\n                            isExpanded={isExpanded}\n                            isSelected={selected === node.id}\n                            tabIndex={focused === node.id ? 0 : -1}\n                            level={level}\n                            positionInSet={positionInSet}\n                            setSize={setSize}\n                            index={node[internalId]}\n                            renderLabel={renderLabel}\n                            onItemSelect={onItemSelect}\n                            onKeyDown={onKeyDown}\n                        />\n                    );\n                })}\n            </ul>\n        </div>\n    );\n};\n\nconst VirtualTree = forwardRef(VirtualTreeImpl);\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    VirtualTree.displayName = 'VirtualTree';\n    VirtualTree.propTypes = {\n        ...basePropTypes,\n    };\n}\n\nexport default memo(VirtualTree);\n"],"names":["noop","isFn","value","isUndefined","getNodeAt","nodes","index","path","split","node","i","length","undefined","moveToParent","current","dataset","item","parentElement","getExpandState","ariaExpandedAttribute","getAttribute","isExpandable","isExpanded","isLastItem","parseInt","shallowEquals","prev","next","ignored","Object","is","keysPrev","keys","filter","key","includes","keysNext","prototype","hasOwnProperty","call","internalId","Symbol","addInternalIds","parentId","result","push","TreeItem","_ref","onItemSelect","renderLabel","focused","selected","expanded","setSize","counter","onKeyDown","props","id","positionInSet","el","useRef","useEffect","focus","firstElementChild","scrollIntoView","block","React","ref","role","tabIndex","onClick","label","map","childIndex","MemoTreeItem","propsAreEqual","stack","shift","memo","valueProp","defaultValue","valueState","setValueState","useState","isUncontrolled","useCallback","TreeImpl","defaultFocused","focusedProp","onFocusChange","defaultExpanded","expandedProp","onExpandChange","selectionTogglesExpanded","selectionFollowsFocus","defaultSelected","selectedProp","onSelectChange","rest","initialFocus","setFocused","useInternalState","setExpanded","setSelected","setCounter","useImperativeHandle","e","altKey","ctrlKey","metaKey","target","currentTarget","preventDefault","previousElementSibling","lastElementChild","moveUp","focusTreeItem","nextElementSibling","moveDown","moveLeft","moveRight","concat","Tree","forwardRef","VirtualTreeItem","measureRef","start","isSelected","level","isFocused","style","position","top","transform","VirtualTreeImpl","rowHeight","parentRef","flattened","useMemo","tree","pop","flattenData","rowVirtualizer","useVirtual","estimateSize","size","rangeExtractor","range","defaultRange","defaultRangeExtractor","focusedIndex","findIndex","Set","parent","slice","join","add","querySelector","scrollToIndex","stopPropagation","parentNode","childNode","treeStyles","height","totalSize","margin","padding","virtualItems","virtualRow","VirtualTree"],"mappings":"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"}