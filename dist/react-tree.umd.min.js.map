{"version":3,"file":"react-tree.umd.min.js","sources":["../src/TreeContext.js","../src/TreeItem.jsx","../src/useInternalState.js","../src/Tree.jsx"],"sourcesContent":["import { createContext } from 'react';\n\nconst TreeContext = createContext({\n    selected: null,\n    focused: null,\n    expanded: [],\n    onItemSelect() {},\n    renderLabel() {},\n});\n\nTreeContext.displayName = 'TreeContext';\n\nexport default TreeContext;\n","import React, { useContext } from 'react';\n\nimport TreeContext from './TreeContext';\n\nconst isFn = (value) => typeof value === 'function';\n\nconst TreeItem = (props) => {\n    const { selected, focused, expanded, onItemSelect, renderLabel } = useContext(TreeContext);\n    const isExpandable = props.nodes.length > 0;\n    const isExpanded = isExpandable ? expanded.includes(props.id) : null;\n\n    return (\n        <li\n            role=\"treeitem\"\n            tabIndex={focused === props.id ? 0 : -1}\n            aria-expanded={isExpanded}\n            aria-selected={selected === props.id ? true : null}\n            data-id={`treeitem-${props.id}`}\n        >\n            {isFn(renderLabel) ? (\n                renderLabel({\n                    ...props,\n                    isExpanded,\n                    isExpandable,\n                    toggleItem() {\n                        onItemSelect(props.id, isExpandable);\n                    },\n                })\n            ) : (\n                <div onClick={() => onItemSelect(props.id, isExpandable)}>{props.label}</div>\n            )}\n\n            {isExpanded && isExpandable && (\n                <ul role=\"group\">\n                    {props.nodes.map((node) => (\n                        <TreeItem {...node} key={node.id} />\n                    ))}\n                </ul>\n            )}\n        </li>\n    );\n};\n\nif (process.env.NODE_ENV !== 'production') {\n    TreeItem.displayName = 'TreeItem';\n}\n\nexport default TreeItem;\n","import { useState, useCallback } from 'react';\n\nconst useInternalState = ({ value: valueProp, defaultValue, onChange }) => {\n    const [valueState, setValueState] = useState(defaultValue);\n    const isUncontrolled = typeof valueProp === 'undefined';\n    const value = isUncontrolled ? valueState : valueProp;\n\n    const updateValue = useCallback(\n        (updater) => {\n            const nextValue = typeof updater === 'function' ? updater(value) : updater;\n\n            if (isUncontrolled) {\n                setValueState(nextValue);\n            }\n\n            onChange(nextValue);\n        },\n        [isUncontrolled, onChange, value]\n    );\n\n    return [value, updateValue];\n};\n\nexport default useInternalState;\n","import React, { useRef, memo } from 'react';\nimport PropTypes from 'prop-types';\n\nimport TreeItem from './TreeItem.jsx';\nimport TreeContext from './TreeContext.js';\nimport useInternalState from './useInternalState.js';\n\nconst noop = () => {};\n\nconst Tree = ({\n    nodes,\n\n    defaultFocused,\n    focused: focusedProp,\n    onFocusChange,\n\n    defaultExpanded = [],\n    expanded: expandedProp,\n    onExpandChange = noop,\n\n    defaultSelected,\n    selected: selectedProp,\n    onSelectChange = noop,\n\n    renderLabel,\n    ...rest\n}) => {\n    const rootEl = useRef(null);\n    const [focused, setFocused] = useInternalState({\n        defaultValue: typeof defaultFocused === 'undefined' && nodes.length > 0 ? nodes[0].id : undefined,\n        value: focusedProp,\n        onChange: typeof onFocusChange === 'function' ? onFocusChange : noop,\n    });\n    const [expanded, setExpanded] = useInternalState({\n        defaultValue: defaultExpanded,\n        value: expandedProp,\n        onChange: typeof onExpandChange === 'function' ? onExpandChange : noop,\n    });\n    const [selected, setSelected] = useInternalState({\n        defaultValue: defaultSelected,\n        value: selectedProp,\n        onChange: typeof onSelectChange === 'function' ? onSelectChange : noop,\n    });\n\n    const onItemSelect = (id, isExpandable) => {\n        if (isExpandable) {\n            setExpanded(expanded.includes(id) ? expanded.filter((node) => node !== id) : expanded.concat(id));\n        }\n\n        setFocused(id);\n        setSelected(id);\n    };\n\n    const moveToTreeItem = (isPrev) => {\n        const items = rootEl.current.querySelectorAll('[role=\"treeitem\"]');\n\n        let nextNode;\n        for (let i = 0; i < items.length; i++) {\n            const element = items[i];\n\n            if (element.tabIndex === 0) {\n                nextNode = isPrev ? items[i - 1] : items[i + 1];\n                break;\n            }\n        }\n\n        if (nextNode) {\n            const id = nextNode.dataset.id.replace('treeitem-', '');\n\n            setFocused(id);\n\n            nextNode.focus();\n            nextNode.firstElementChild.scrollIntoView({ block: 'center' });\n        }\n    };\n\n    const onKeyDown = (e) => {\n        if (!nodes.length || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n        }\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n\n            // move to previous node that is visible on the screen\n            moveToTreeItem(true);\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n\n            // move to next node that is visible on the screen\n            moveToTreeItem(false);\n        } else if (e.key === 'ArrowLeft') {\n            e.preventDefault();\n\n            const { treeItem, isExpandable, isExpanded } = getTreeItem(focused);\n\n            if (isExpandable && isExpanded) {\n                // close node\n                setExpanded(expanded.filter((node) => node !== focused));\n            } else {\n                // move focus to parent node\n                focusItem(treeItem.closest('[role=\"treeitem\"]:not([tabindex=\"0\"])'));\n            }\n        } else if (e.key === 'ArrowRight') {\n            e.preventDefault();\n\n            const { treeItem, isExpandable, isExpanded } = getTreeItem(focused);\n\n            if (isExpandable) {\n                if (isExpanded) {\n                    // move focus to next child node\n                    focusItem(treeItem.querySelector('[role=\"treeitem\"]'));\n                } else {\n                    // open node\n                    setExpanded(expanded.concat(focused));\n                }\n            }\n        } else if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n\n            const isExpandable = rootEl.current\n                .querySelector(`[data-id=\"treeitem-${focused}\"]`)\n                .hasAttribute('aria-expanded');\n\n            onItemSelect(focused, isExpandable);\n        }\n    };\n\n    const getTreeItem = (id) => {\n        const treeItem = rootEl.current.querySelector(`[data-id=\"treeitem-${id}\"]`);\n\n        return {\n            treeItem,\n            isExpandable: treeItem.hasAttribute('aria-expanded'),\n            isExpanded: treeItem.getAttribute('aria-expanded') === 'true',\n        };\n    };\n\n    const focusItem = (item) => {\n        if (item) {\n            item.focus();\n            item.firstElementChild.scrollIntoView({ block: 'center' });\n\n            const id = item.dataset.id.replace('treeitem-', '');\n\n            setFocused(id);\n        }\n    };\n\n    return (\n        <TreeContext.Provider value={{ selected, focused, expanded, onItemSelect, renderLabel }}>\n            <ul role=\"tree\" onKeyDown={onKeyDown} {...rest} ref={rootEl}>\n                {nodes.map((node) => (\n                    <TreeItem {...node} key={node.id} />\n                ))}\n            </ul>\n        </TreeContext.Provider>\n    );\n};\n\nif (process.env.NODE_ENV !== 'production') {\n    const getErrorForControlled = (propName, componentName, handlerName, defaultPropName) => {\n        return (\n            `You provided a \\`${propName}\\` prop to ${componentName} without an \\`${handlerName}\\` handler. ` +\n            `This will cause the ${componentName} component to behave incorrectly. ` +\n            `If the ${componentName} should be mutable use \\`${defaultPropName}\\` instead. Otherwise, set \\`${handlerName}\\`.`\n        );\n    };\n\n    const getErrorForUncontrolled = (propName, componentName, handlerName, defaultPropName) => {\n        return (\n            `You provided a \\`${propName}\\` prop as well as a \\`${defaultPropName}\\` prop to ${componentName}. ` +\n            `If you want a controlled component, use the \\`${propName}\\` prop with an \\`${handlerName}\\` handler. ` +\n            `If you want an uncontrolled component, remove the \\`${propName}\\` prop and use \\`${defaultPropName}\\` instead.`\n        );\n    };\n\n    const getGenericTypeError = (name, componentName, expectedType, value) => {\n        return `Invalid prop \\`${name}\\` supplied to ${componentName}. Expected \\`${expectedType}\\`, received \\`${\n            Array.isArray(value) ? 'array' : typeof value\n        }\\`.`;\n    };\n\n    let nodeShape = {\n        id: PropTypes.string.isRequired,\n        label: PropTypes.oneOfType([PropTypes.string, PropTypes.node]).isRequired,\n    };\n    nodeShape.nodes = PropTypes.arrayOf(PropTypes.shape(nodeShape));\n\n    Tree.displayName = 'Tree';\n    Tree.propTypes = {\n        nodes: PropTypes.arrayOf(PropTypes.shape(nodeShape)).isRequired,\n\n        defaultFocused: PropTypes.string,\n        focused: (props, name, componentName, location) => {\n            const value = props[name];\n            const comp = `\\`<${componentName}>\\``;\n\n            if (typeof value === 'string' && props.onFocusChange == null) {\n                return new Error(getErrorForControlled(name, comp, 'onFocusChange', 'defaultFocused'));\n            }\n\n            if (value != null && props.defaultFocused != null) {\n                return new Error(getErrorForUncontrolled(name, comp, 'onFocusChange', 'defaultFocused'));\n            }\n\n            if (value != null && typeof value !== 'string') {\n                return new Error(getGenericTypeError(name, comp, 'string', value));\n            }\n\n            return null;\n        },\n        onFocusChange: PropTypes.func,\n\n        defaultExpanded: PropTypes.arrayOf(PropTypes.string),\n        // expanded: PropTypes.arrayOf(PropTypes.string),\n        expanded: (props, name, componentName, location) => {\n            const value = props[name];\n            const comp = `\\`<${componentName}>\\``;\n\n            if (Array.isArray(value) && props.onExpandChange == null) {\n                return new Error(getErrorForControlled(name, comp, 'onExpandChange', 'defaultExpanded'));\n            }\n\n            if (value != null && props.defaultExpanded != null) {\n                return new Error(getErrorForUncontrolled(name, comp, 'onExpandChange', 'defaultExpanded'));\n            }\n\n            if (Array.isArray(value)) {\n                const message = `You provided an array as an index in ${comp} but one or more of the values are not string.`;\n\n                return value.some((i) => typeof i !== 'string') ? new Error(message) : null;\n            }\n\n            if (value != null && !Array.isArray(value)) {\n                return new Error(getGenericTypeError(name, comp, 'array', value));\n            }\n\n            return null;\n        },\n        onExpandChange: PropTypes.func,\n\n        defaultSelected: PropTypes.string,\n        selected: (props, name, componentName, location) => {\n            const value = props[name];\n            const comp = `\\`<${componentName}>\\``;\n\n            if (typeof value === 'string' && props.onSelectChange == null) {\n                return new Error(getErrorForControlled(name, comp, 'onSelectChange', 'defaultSelected'));\n            }\n\n            if (value != null && props.defaultSelected != null) {\n                return new Error(getErrorForUncontrolled(name, comp, 'onSelectChange', 'defaultSelected'));\n            }\n\n            if (value != null && typeof value !== 'string') {\n                return new Error(getGenericTypeError(name, comp, 'string', value));\n            }\n\n            return null;\n        },\n        onSelectChange: PropTypes.func,\n\n        renderLabel: PropTypes.func,\n    };\n}\n\nexport default memo(Tree);\n"],"names":["TreeContext","createContext","selected","focused","expanded","onItemSelect","renderLabel","displayName","TreeItem","props","useContext","isExpandable","nodes","length","isExpanded","includes","id","React","role","tabIndex","toggleItem","onClick","label","map","node","key","useInternalState","value","valueProp","defaultValue","onChange","valueState","setValueState","useState","isUncontrolled","updateValue","useCallback","updater","nextValue","noop","Tree","defaultFocused","focusedProp","onFocusChange","defaultExpanded","expandedProp","onExpandChange","defaultSelected","selectedProp","onSelectChange","rest","rootEl","useRef","setFocused","undefined","setExpanded","setSelected","filter","concat","moveToTreeItem","isPrev","items","current","querySelectorAll","nextNode","i","dataset","replace","focus","firstElementChild","scrollIntoView","block","getTreeItem","treeItem","querySelector","hasAttribute","getAttribute","focusItem","item","Provider","onKeyDown","e","altKey","ctrlKey","metaKey","preventDefault","closest","ref","memo"],"mappings":"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"}